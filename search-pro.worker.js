const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":126,\"nextId\":126,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-0d92cf12\",\"2\":\"v-29c84ff8\",\"3\":\"v-29c84ff8#方法一、穷举法\",\"4\":\"v-29c84ff8#方法二、哈希法\",\"5\":\"v-29c84ff8@0\",\"6\":\"v-3ee9b548\",\"7\":\"v-33b576f2\",\"8\":\"v-33b576f2#单链表缺点\",\"9\":\"v-33b576f2#双向链表\",\"10\":\"v-33b576f2#代码实现\",\"11\":\"v-33b576f2#创建node节点\",\"12\":\"v-33b576f2#初始化头节点\",\"13\":\"v-33b576f2#顺序添加节点\",\"14\":\"v-33b576f2#根据age删除节点\",\"15\":\"v-33b576f2#遍历\",\"16\":\"v-33b576f2#根据age修改节点\",\"17\":\"v-33b576f2#根据age插入节点\",\"18\":\"v-33b576f2#完整代码\",\"19\":\"v-33b576f2@0\",\"20\":\"v-128475d2\",\"21\":\"v-128475d2#单向环形链表应用场景\",\"22\":\"v-128475d2#代码实现\",\"23\":\"v-128475d2#初始化节点\",\"24\":\"v-128475d2#初始化环形链表\",\"25\":\"v-128475d2#遍历所有节点\",\"26\":\"v-128475d2#报数出队\",\"27\":\"v-128475d2#完整代码\",\"28\":\"v-128475d2@0\",\"29\":\"v-8bdcdcca\",\"30\":\"v-8bdcdcca#链表介绍\",\"31\":\"v-8bdcdcca#代码实现\",\"32\":\"v-8bdcdcca#node节点\",\"33\":\"v-8bdcdcca#单链表初始化\",\"34\":\"v-8bdcdcca#顺序添加节点\",\"35\":\"v-8bdcdcca#根据age大小插入节点\",\"36\":\"v-8bdcdcca#根据age删除节点\",\"37\":\"v-8bdcdcca#根据age修改节点\",\"38\":\"v-8bdcdcca#面试题\",\"39\":\"v-8bdcdcca#获取链表有效节点个数-去除头节点-新浪面试题\",\"40\":\"v-8bdcdcca#获取倒数k个节点-新浪面试题\",\"41\":\"v-8bdcdcca#数组反转-1-2-3-变成3-2-1-腾讯面试题\",\"42\":\"v-8bdcdcca#逆序打印-百度面试题\",\"43\":\"v-8bdcdcca#完整代码\",\"44\":\"v-8bdcdcca@0\",\"45\":\"v-4ea484b1\",\"46\":\"v-4ea484b1#队列介绍\",\"47\":\"v-4ea484b1#数组模拟队列思路\",\"48\":\"v-4ea484b1#代码实现\",\"49\":\"v-4ea484b1#初始化\",\"50\":\"v-4ea484b1#队空\",\"51\":\"v-4ea484b1#队满\",\"52\":\"v-4ea484b1#添加数据-入队\",\"53\":\"v-4ea484b1#出队\",\"54\":\"v-4ea484b1#显示队列头数据-不取出\",\"55\":\"v-4ea484b1#完整代码\",\"56\":\"v-4ea484b1#问题及解决方案\",\"57\":\"v-4ea484b1@0\",\"58\":\"v-7e5969e1\",\"59\":\"v-7e5969e1#分析说明\",\"60\":\"v-7e5969e1#代码实现\",\"61\":\"v-7e5969e1#初始化\",\"62\":\"v-7e5969e1#队空\",\"63\":\"v-7e5969e1#队满\",\"64\":\"v-7e5969e1#添加数据\",\"65\":\"v-7e5969e1#出队\",\"66\":\"v-7e5969e1#有效数据个数\",\"67\":\"v-7e5969e1#完整代码\",\"68\":\"v-7e5969e1@0\",\"69\":\"v-05ea0a63\",\"70\":\"v-05ea0a63#概念\",\"71\":\"v-05ea0a63#实际问题\",\"72\":\"v-05ea0a63#迷宫问题\",\"73\":\"v-05ea0a63#代码实现\",\"74\":\"v-05ea0a63#初始化地图\",\"75\":\"v-05ea0a63#打印地图\",\"76\":\"v-05ea0a63#迷宫求解\",\"77\":\"v-05ea0a63#完整代码\",\"78\":\"v-05ea0a63#八皇后问题\",\"79\":\"v-05ea0a63#思路分析\",\"80\":\"v-05ea0a63#算法实现\",\"81\":\"v-05ea0a63@0\",\"82\":\"v-8c01ce9a\",\"83\":\"v-8c01ce9a#需求\",\"84\":\"v-8c01ce9a#基本介绍\",\"85\":\"v-8c01ce9a#代码实现\",\"86\":\"v-8c01ce9a@0\",\"87\":\"v-6f9af484\",\"88\":\"v-6f9af484#前缀、中缀、后缀表达式\",\"89\":\"v-6f9af484#中缀表达式\",\"90\":\"v-6f9af484#前缀表达式\",\"91\":\"v-6f9af484#后缀表达式\",\"92\":\"v-6f9af484#前缀表达式求值\",\"93\":\"v-6f9af484#中缀表达式求值\",\"94\":\"v-6f9af484#定义几个工具方法\",\"95\":\"v-6f9af484#完整代码\",\"96\":\"v-6f9af484#后缀表达式求值\",\"97\":\"v-6f9af484#中缀表达式转后缀表达式\",\"98\":\"v-6f9af484#代码实现\",\"99\":\"v-6f9af484@0\",\"100\":\"v-dcd42f6c\",\"101\":\"v-dcd42f6c#栈的介绍\",\"102\":\"v-dcd42f6c#栈的应用场景\",\"103\":\"v-dcd42f6c#数组模拟栈\",\"104\":\"v-dcd42f6c#初始化\",\"105\":\"v-dcd42f6c#栈满\",\"106\":\"v-dcd42f6c#栈空\",\"107\":\"v-dcd42f6c#入栈push\",\"108\":\"v-dcd42f6c#出栈pop\",\"109\":\"v-dcd42f6c#遍历\",\"110\":\"v-dcd42f6c#完整代码\",\"111\":\"v-dcd42f6c#链表模拟栈\",\"112\":\"v-dcd42f6c#定义node节点\",\"113\":\"v-dcd42f6c#初始化链表\",\"114\":\"v-dcd42f6c#满与空\",\"115\":\"v-dcd42f6c#入栈push-1\",\"116\":\"v-dcd42f6c#出栈pop-1\",\"117\":\"v-dcd42f6c#遍历-1\",\"118\":\"v-dcd42f6c#完整代码-1\",\"119\":\"v-dcd42f6c@0\",\"120\":\"v-e52c881c\",\"121\":\"v-049da102\",\"122\":\"v-7cc07a60\",\"123\":\"v-e47eacc2\",\"124\":\"v-5e31ef28\",\"125\":\"v-760d6f8e\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,2],\"1\":[1,21],\"2\":[3,3],\"3\":[2,21],\"4\":[2,25],\"5\":[null,null,1],\"6\":[1,3],\"7\":[1],\"8\":[1,11],\"9\":[1,17],\"10\":[1],\"11\":[1,23],\"12\":[1,10],\"13\":[1,23],\"14\":[1,50],\"15\":[1,22],\"16\":[1,33],\"17\":[1,44],\"18\":[1,100],\"19\":[null,null,1],\"20\":[2],\"21\":[1,46],\"22\":[1],\"23\":[1,10],\"24\":[1,49],\"25\":[1,25],\"26\":[1,91],\"27\":[1,101],\"28\":[null,null,1],\"29\":[1],\"30\":[1,26],\"31\":[1],\"32\":[1,19],\"33\":[1,11],\"34\":[1,23],\"35\":[1,42],\"36\":[1,41],\"37\":[1,34],\"38\":[1],\"39\":[3,18],\"40\":[2,30],\"41\":[6,28],\"42\":[2,36],\"43\":[1,137],\"44\":[null,null,1],\"45\":[1],\"46\":[1,14],\"47\":[1,30],\"48\":[1],\"49\":[1,23],\"50\":[1,9],\"51\":[1,10],\"52\":[3,19],\"53\":[1,16],\"54\":[3,18],\"55\":[1,72],\"56\":[1,6],\"57\":[null,null,2],\"58\":[1,5],\"59\":[1,20],\"60\":[1],\"61\":[1,21],\"62\":[1,9],\"63\":[1,12],\"64\":[1,22],\"65\":[1,21],\"66\":[1,10],\"67\":[1,77],\"68\":[null,null,2],\"69\":[3],\"70\":[1,5],\"71\":[1,14],\"72\":[1,20],\"73\":[1],\"74\":[1,30],\"75\":[1,24],\"76\":[1,61],\"77\":[1,92],\"78\":[1,16],\"79\":[1,49],\"80\":[1,58],\"81\":[null,null,1],\"82\":[1],\"83\":[1,7],\"84\":[1,35],\"85\":[1,76],\"86\":[null,null,1],\"87\":[3],\"88\":[3],\"89\":[1,17],\"90\":[1,15],\"91\":[1,13],\"92\":[1,43],\"93\":[1,38],\"94\":[1,49],\"95\":[1,143],\"96\":[1,115],\"97\":[1,31],\"98\":[1,134],\"99\":[null,null,1],\"100\":[1],\"101\":[1,36],\"102\":[1,20],\"103\":[1],\"104\":[1,20],\"105\":[1,12],\"106\":[1,9],\"107\":[1,21],\"108\":[1,20],\"109\":[1,23],\"110\":[1,56],\"111\":[1],\"112\":[1,9],\"113\":[1,20],\"114\":[1,15],\"115\":[1,33],\"116\":[1,22],\"117\":[1,26],\"118\":[1,61],\"119\":[null,null,1],\"120\":[1],\"121\":[1],\"122\":[1],\"123\":[1],\"124\":[1],\"125\":[1]},\"averageFieldLength\":[1.2165728614337576,32.21831952483568,0.33627597694221534],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"计算机学徒   BUG制造者\"]},\"1\":{\"h\":\"数据结构与算法\",\"t\":[\"#1 稀疏数组\",\"#2 数组队列\",\"#3 环形队列\",\"#4 单链表\",\"#5 双链表\",\"#6 环形链表\",\"#7 栈\",\"#8 前缀、中缀、后缀表达式\",\"#9 递归\"]},\"2\":{\"h\":\"Leetcode#1: 两数之和\",\"t\":[\"Leetcode#1: 两数之和\"]},\"3\":{\"h\":\"方法一、穷举法\",\"t\":[\" public int[] twoSum(int[] nums, int target) { for (int i = 0; i < nums.length; i++) { for (int j = 0; j < nums.length; j++) { if (i != j && nums[i] + nums[j] == target) { return new int[]{i, j}; } } } return null; } \"]},\"4\":{\"h\":\"方法二、哈希法\",\"t\":[\" public int[] twoSum(int[] nums, int target) { int length = nums.length; Map<Integer, Integer> map = new HashMap<>(); for (int i = 0; i < length; i++) { int num = target - nums[i]; if (map.containsKey(num)) { return new int[]{map.get(num), i}; } map.put(nums[i], i); } return null; } \"]},\"5\":{\"c\":[\"Leetcode\"]},\"6\":{\"h\":\"LeetCode\",\"t\":[\"Leetcode#1 两数之和\"]},\"7\":{\"h\":\"双向链表\"},\"8\":{\"h\":\"单链表缺点\",\"t\":[\"单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找\",\"单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到 temp，temp 是待删除节点的前一个节点\"]},\"9\":{\"h\":\"双向链表\",\"t\":[\"双向链表\",\"遍历和单链表一样，只是可以向前，也可以向后查找\",\"添加 (默认添加到双向链表的最后)\",\"先找到双向链表的最后这个节点\",\"temp.next = newNode\",\"newNode.pre = temp\",\"修改思路和原来的单向链表一样\",\"因为是双向链表，因此可以实现自我删除某个节点\",\"直接找到要删除的这个节点，比如 temp\",\"temp.pre.next = temp.next\",\"temp.next.pre = temp.pre\"]},\"10\":{\"h\":\"代码实现\"},\"11\":{\"h\":\"创建Node节点\",\"t\":[\"因为是双向链表所以有pre和next，分别指向上一个节点和下一个节点\",\"class DoubleNode { public int age; public String name; public DoubleNode pre; //指向上一个节点 默认是null public DoubleNode next; //指向下一个节点 默认是null public DoubleNode() { } public DoubleNode(int age, String name) { this.age = age; this.name = name; } @Override public String toString() { return \\\"DoubleNode{\\\" + \\\"age=\\\" + age + \\\", name='\\\" + name + '\\\\'' + '}'; } } \"]},\"12\":{\"h\":\"初始化头节点\",\"t\":[\"public class DoubleLinkedList { //初始化头节点 private DoubleNode head = new DoubleNode(); } \"]},\"13\":{\"h\":\"顺序添加节点\",\"t\":[\" //顺序添加节点 public void add(DoubleNode node) { //将最后节点的next指向新的节点 DoubleNode temp = head; while (true) { //最后一个节点 if (temp.next == null) { break; } //没找到最后一个节点就后移 temp = temp.next; } //最后一个节点next指向新节点 temp.next = node; //新节点的pre的指向最后一个节点 node.pre = temp; } \"]},\"14\":{\"h\":\"根据Age删除节点\",\"t\":[\"重点是理解 temp.pre.next = temp.next和 temp.next.pre = temp.pre\",\"删除节点时候需将待删除节点的上一个节点的next指向待删除节点的下一个节点，即temp.pre.next = temp.next\",\"同时将待删除节点的下一个节点的pre指向待删除结点的上一个节点，即temp.next.pre = temp.pre\",\"与单链表不同的是 单链表需要找到删除节点的前一个节点 而双链表可以直接找到删除的节点自我删除\",\" //删除节点 按照age 1=2=3变成1=3 //与单链表不同的是 单链表需要找到删除节点的前一个节点 而双链表可以直接找到删除的节点自我删除 public void delByAge(int age) { if (head.next == null) { System.out.println(\\\"双向链表为空，无法删除！\\\"); return; } DoubleNode temp = head.next; //辅助指针 boolean isFind = false;//判断是否找到 while (true) { if (temp == null) { //到达链表尾部 break; } if (temp.age == age) { //找到要删除节点位置 isFind = true; break; } temp = temp.next; } if (!isFind) { //不存在 System.out.println(\\\"删除失败，数据不存在！！\\\"); return; } //此时temp为要删除节点 //1-3 temp.pre.next = temp.next; //1=3(temp如果是最后一个则不执行) if (temp.next != null) { temp.next.pre = temp.pre; } } \"]},\"15\":{\"h\":\"遍历\",\"t\":[\"和单链表遍历没区别\",\" //遍历双向链表 public void showList() { //判空 if (head.next == null) { return; } DoubleNode temp = head.next; while (true) { if (temp == null) { break; } System.out.println(temp); temp = temp.next; } } \"]},\"16\":{\"h\":\"根据Age修改节点\",\"t\":[\"和单链表没区别，都是找到节点然后直接修改\",\" //根据Age修改节点 和单向链表一样 public void editByAge(DoubleNode node) { if (head.next == null) { System.out.println(\\\"双向链表为空！\\\"); return; } DoubleNode temp = head.next; boolean isFind = false;//判断是否找到 while (true) { if (temp == null) { break; } if (temp.age == node.age) { isFind = true; break; } temp = temp.next; } if (!isFind) { System.out.println(\\\"修改失败，数据不存在！！\\\"); return; } temp.name = node.name; } \"]},\"17\":{\"h\":\"根据Age插入节点\",\"t\":[\"插入时首先将待插入节点node的上一个位置，即temp\",\"将node的下一个节点指向temp的下一个节点 ，将temp下一个节点的pre指向node\",\"将temp下一节点指向node，将node的 上一个节点指向temp\",\" //按照年纪从小到大插入节点 例如2应该插入1=3之间变成1=2=3 //如果已经存在则添加失败 public void addByAge(DoubleNode node) { DoubleNode temp = head.next; boolean isExist = false;//判断是否已经存在 while (true) { if (temp.next == null) { break; } if (temp.next.age > node.age) { //找到位置 break; } else if (temp.next.age == node.age) { //已经存在 isExist = true; break; } temp = temp.next; } if (isExist) { //已经存在 System.out.println(\\\"插入失败，已经存在！！\\\"); return; } //此时temp=1 //2=3 node.next = temp.next; temp.next.pre = node; //1=2 temp.next = node; node.pre = temp; } \"]},\"18\":{\"h\":\"完整代码\",\"t\":[\"public class DoubleLinkedList { //初始化头节点 private DoubleNode head = new DoubleNode(); //遍历双向链表 public void showList() { //判空 if (head.next == null) { return; } DoubleNode temp = head.next; while (true) { if (temp == null) { break; } System.out.println(temp); temp = temp.next; } } //顺序添加节点 public void add(DoubleNode node) { //将最后节点的next指向新的节点 DoubleNode temp = head; while (true) { //最后一个节点 if (temp.next == null) { break; } //没找到最后一个节点就后移 temp = temp.next; } //最后一个节点next指向新节点 temp.next = node; //新节点的pre的指向最后一个节点 node.pre = temp; } //根据Age修改节点 和单向链表一样 public void editByAge(DoubleNode node) { if (head.next == null) { System.out.println(\\\"双向链表为空！\\\"); return; } DoubleNode temp = head.next; boolean isFind = false;//判断是否找到 while (true) { if (temp == null) { break; } if (temp.age == node.age) { isFind = true; break; } temp = temp.next; } if (!isFind) { System.out.println(\\\"修改失败，数据不存在！！\\\"); return; } temp.name = node.name; } //删除节点 按照age 1=2=3变成1=3 //与单链表不同的是 单链表需要找到删除节点的前一个节点 而双链表可以直接找到删除的节点自我删除 public void delByAge(int age) { if (head.next == null) { System.out.println(\\\"双向链表为空，无法删除！\\\"); return; } DoubleNode temp = head.next; //辅助指针 boolean isFind = false;//判断是否找到 while (true) { if (temp == null) { //到达链表尾部 break; } if (temp.age == age) { //找到要删除节点位置 isFind = true; break; } temp = temp.next; } if (!isFind) { //不存在 System.out.println(\\\"删除失败，数据不存在！！\\\"); return; } //此时temp为要删除节点 //1-3 temp.pre.next = temp.next; //1=3(temp如果是最后一个则不执行) if (temp.next != null) { temp.next.pre = temp.pre; } } //按照年纪从小到大插入节点 例如2应该插入1=3之间变成1=2=3 //如果已经存在则添加失败 public void addByAge(DoubleNode node) { DoubleNode temp = head.next; boolean isExist = false;//判断是否已经存在 while (true) { if (temp.next == null) { break; } if (temp.next.age > node.age) { //找到位置 break; } else if (temp.next.age == node.age) { //已经存在 isExist = true; break; } temp = temp.next; } if (isExist) { //已经存在 System.out.println(\\\"插入失败，已经存在！！\\\"); return; } //此时temp=1 //2=3 node.next = temp.next; temp.next.pre = node; //1=2 temp.next = node; node.pre = temp; } public static void main(String[] args) { DoubleLinkedList list = new DoubleLinkedList(); DoubleNode yi = new DoubleNode(1, \\\"yi\\\"); DoubleNode er = new DoubleNode(2, \\\"er\\\"); DoubleNode san = new DoubleNode(3, \\\"san\\\"); DoubleNode si = new DoubleNode(4, \\\"si\\\"); list.add(yi); list.add(er); list.add(si); list.showList(); System.out.println(\\\"###############\\\"); list.addByAge(san); list.showList(); System.out.println(\\\"###############\\\"); list.delByAge(4); list.showList(); } } class DoubleNode { public int age; public String name; public DoubleNode pre; //指向上一个节点 默认是null public DoubleNode next; //指向下一个节点 默认是null public DoubleNode() { } public DoubleNode(int age, String name) { this.age = age; this.name = name; } @Override public String toString() { return \\\"DoubleNode{\\\" + \\\"age=\\\" + age + \\\", name='\\\" + name + '\\\\'' + '}'; } } \"]},\"19\":{\"c\":[\"链表\"]},\"20\":{\"h\":\"环形链表-约瑟夫问题\"},\"21\":{\"h\":\"单向环形链表应用场景\",\"t\":[\"环形链表\",\"Josephu(约瑟夫、约瑟夫环) 问题\",\"Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。\",\"例子：\",\"n=5 即有五个人\",\"k=1 即从1号开始报数\",\"m=2 即报数为2的出列\",\"最后的顺序是 2-4-1-5-3\",\"约瑟夫问题解题思路：\",\"使用环形链表来模拟\",\"使用两个指针first和last分别表示第一个和最后一个\",\"first报数时移动到报数为m的位置，last移动到first的上一个位置也就是环形的队尾\",\"然后出队删除first所在位置，同时将first指向下一个位置（在这个位置重新报数），同时将last的next指向first，使得始终维持一个环形队列\"]},\"22\":{\"h\":\"代码实现\"},\"23\":{\"h\":\"初始化节点\",\"t\":[\"class Boy { public int no;//编号 public Boy next; public Boy(int no) { this.no = no; } } \"]},\"24\":{\"h\":\"初始化环形链表\",\"t\":[\"初始化第一个节点为first为空，然后addBoy用于构建环形队列\",\"当i==1时候，将first赋值为编号1的Boy，并且创建尾节点last使得last.next=first保持环形\",\"其余节点类似，但始终保持最后一个节点的next为first节点\",\"class CircleSingleLinkedList { //第一个节点 private Boy first = null; //添加小孩节点，构建环形链表（nums个小孩） public void addBoy(int nums) { if (nums < 1) { System.out.println(\\\"nums值不正确\\\"); return; } Boy last = null; //辅助指针 用于构建环形链表 总是指向尾节点 for (int i = 1; i <= nums; i++) { //根据编号创建小孩节点 Boy boy = new Boy(i); //第一个节点 if (i == 1) { //1 first = boy; first.next = first; //构成环 last = first; } else { //1-2 last.next = boy; //1-2-1 boy.next = first; last = boy; } } } } \"]},\"25\":{\"h\":\"遍历所有节点\",\"t\":[\" public void showBoy() { if (first == null) { System.out.println(\\\"链表为空\\\"); return; } //辅助指针 Boy cur = first; while (true) { System.out.println(\\\"编号：\\\" + cur.no); if (cur.next == first) { System.out.println(\\\"遍历完毕\\\"); break; } cur = cur.next; } } \"]},\"26\":{\"h\":\"报数出队\",\"t\":[\"和上面解题思路一样 环形队列1-2-3-4-5-1\",\"得到first和last指针表示环形队列队头和队尾（即第一个报数的人和最后一个报数的人）例如从1号开始报数，则first=1，last=5\",\"报m则移动m-1位置因为本身得报一个数，例如m=2，则第一个出队的将是2号，此时first和last都移动1位，first=2，last=1\",\"2号出队，则从3号重新报数，则first=3，lsat=1必须指向3才可以位置环形队列，所以last.next=first\",\" /** * @param startNo 表示从第几个小孩开始数数 * @param countNum 表示数几下 * @param nums 表示初始有几个小孩 */ public void countBoy(int startNo, int countNum, int nums) { //数据校验 if (first == null || startNo < 1 || startNo > nums) { System.out.println(\\\"输入数据不正确！\\\"); return; } Boy last = first; //辅助指针 指向尾节点 while (true) { if (last.next == first) { break; } last = last.next; } //报数前先移动startNo - 1次（因为本身已经在第一位了） //比如刚开始last=5 first=1 startNo=1 //那我们先将last和first移动startNo-1位 for (int i = 0; i < startNo - 1; i++) { first = first.next; last = last.next; } //报数时，移动countNum-1次 因为本身（last、first）自己也的报数一次 //假设countNum=2，那么报两次 则第一个出圈是2（报数1、2）下次一次从3开始报数 //刚开始last=5 first=1 while (true) { if (last == first) { //说明只剩下最后一个节点 break; } for (int i = 0; i < countNum - 1; i++) { first = first.next; //此时first=2 last = last.next; //此时last=1 } System.out.println(\\\"出圈：\\\" + first.no); //first指向的2出圈 first = first.next;//此时first=3 last.next = first;//此时last=1->first=3 } System.out.println(\\\"最后存留的编号：\\\" + first.no); } \"]},\"27\":{\"h\":\"完整代码\",\"t\":[\"public class Josephu { public static void main(String[] args) { CircleSingleLinkedList list = new CircleSingleLinkedList(); list.addBoy(5); //5个小孩 list.showBoy(); list.countBoy(1, 2, 5); //结果 24153 } } class CircleSingleLinkedList { //第一个节点 private Boy first = null; //添加小孩节点，构建环形链表（nums个小孩） public void addBoy(int nums) { if (nums < 1) { System.out.println(\\\"nums值不正确\\\"); return; } Boy last = null; //辅助指针 用于构建环形链表 总是指向尾节点 for (int i = 1; i <= nums; i++) { //根据编号创建小孩节点 Boy boy = new Boy(i); //第一个节点 if (i == 1) { //1 first = boy; first.next = first; //构成环 last = first; } else { //1-2 last.next = boy; //1-2-1 boy.next = first; last = boy; } } } public void showBoy() { if (first == null) { System.out.println(\\\"链表为空\\\"); return; } //辅助指针 Boy cur = first; while (true) { System.out.println(\\\"编号：\\\" + cur.no); if (cur.next == first) { System.out.println(\\\"遍历完毕\\\"); break; } cur = cur.next; } } /** * @param startNo 表示从第几个小孩开始数数 * @param countNum 表示数几下 * @param nums 表示初始有几个小孩 */ public void countBoy(int startNo, int countNum, int nums) { //数据校验 if (first == null || startNo < 1 || startNo > nums) { System.out.println(\\\"输入数据不正确！\\\"); return; } Boy last = first; //辅助指针 指向尾节点 while (true) { if (last.next == first) { break; } last = last.next; } //报数前先移动startNo - 1次（因为本身已经在第一位了） //比如刚开始last=5 first=1 startNo=1 //那我们先将last和first移动startNo-1位 for (int i = 0; i < startNo - 1; i++) { first = first.next; last = last.next; } //报数时，移动countNum-1次 因为本身（last、first）自己也的报数一次 //假设countNum=2，那么报两次 则第一个出圈是2（报数1、2）下次一次从3开始报数 //刚开始last=5 first=1 while (true) { if (last == first) { //说明只剩下最后一个节点 break; } for (int i = 0; i < countNum - 1; i++) { first = first.next; //此时first=2 last = last.next; //此时last=1 } System.out.println(\\\"出圈：\\\" + first.no); //first指向出圈 first = first.next;//此时first=3 last.next = first;//此时last=1->first=3 } System.out.println(\\\"最后存留的编号：\\\" + first.no); } } class Boy { public int no;//编号 public Boy next; public Boy(int no) { this.no = no; } } \"]},\"28\":{\"c\":[\"链表\"]},\"29\":{\"h\":\"单链表\"},\"30\":{\"h\":\"链表介绍\",\"t\":[\"链表是有序的列表，但是它在内存中是存储如下（没学过操作系统可以忽略）：\",\"实际内存存储结构\",\"链表是以节点的方式来存储，是链式存储\",\"每个节点包含 data 域：存储数据 next 域：指向下一个节点\",\"如图：发现链表的各个节点不一定是连续存储（没学过操作系统可以忽略）\",\"链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定\",\"单链表(带头结点) 逻辑结构示意图如下\",\"简略图\",\"详细图\",\"即一个完整的链表通常包括 head->node->node->node\",\"其中head不存储信息 每个node包括data和next\"]},\"31\":{\"h\":\"代码实现\"},\"32\":{\"h\":\"Node节点\",\"t\":[\"class Node { public int age; public String name; public Node next; //指向下一个节点 public Node() { } public Node(int age, String name) { this.age = age; this.name = name; } @Override public String toString() { return \\\"Node{\\\" + \\\"age=\\\" + age + \\\", name='\\\" + name + '\\\\'' + '}'; } } \",\"每个Node节点包括的data为age和name，然后next用于指向下一个节点\"]},\"33\":{\"h\":\"单链表初始化\",\"t\":[\"public class SingleLinkedList { private Node head = new Node(); //头节点 不存数据 } \"]},\"34\":{\"h\":\"顺序添加节点\",\"t\":[\" //顺序添加节点 public void add(Node node) { //目的是将最后节点的next指向新的节点 Node temp = head; //辅助节点 while (true) { //表示最后一个节点 if (temp.next == null) { break; } //没到最后一个节点就后移 temp = temp.next; } //此时temp为最后一个节点，将最后一个节点的next指向新节点即添加成功 temp.next = node; } \"]},\"35\":{\"h\":\"根据Age大小插入节点\",\"t\":[\" //按照Age从小到大插入节点 例如2应该插入1-3之间变成1-2-3 //如果2已经存在则添加失败 public void addByAge(Node node) { Node temp = head; //辅助接点 boolean isExist = false;//判断2是否已经存在 while (true) { if (temp.next == null) { //已经到达链表尾部 break; } if (temp.next.age > node.age) { //找到合适位置 3>2 break; } else if (temp.next.age == node.age) { //已经存在 isExist = true; break; } temp = temp.next; //没找到继续后移 } if (isExist) { //如果已经存在 System.out.println(\\\"插入失败，已经存在！！\\\"); return; } //2-3 node.next = temp.next; //1-2 temp.next = node; } \"]},\"36\":{\"h\":\"根据Age删除节点\",\"t\":[\" //删除节点 按照age 例如删除2，则1-2-3变成1-3 public void delByAge(int age) { Node temp = head;//辅助接点 boolean isFind = false;//判断是否找到 while (true) { if (temp.next == null) { //到达链表尾部 break; } if (temp.next.age == age) { //找到要删除节点的前一个位置！！！ 1.next==2 isFind = true; break; } temp = temp.next; //没找到继续后移 } if (!isFind) { //没找到 System.out.println(\\\"删除失败，数据不存在！！\\\"); return; } //1-3 temp.next = temp.next.next; } \"]},\"37\":{\"h\":\"根据Age修改节点\",\"t\":[\" //根据Age修改节点 public void editByAge(Node node) { if (head.next == null) { System.out.println(\\\"链表为空！\\\"); return; } Node temp = head.next; //辅助节点 boolean isFind = false;//判断是否找到 while (true) { if (temp == null) { //到达尾部 break; } if (temp.age == node.age) { //找到对应节点 isFind = true; break; } temp = temp.next; } if (!isFind) { System.out.println(\\\"修改失败，数据不存在！！\\\"); return; } //将对应节点的name修改 temp.name = node.name; } \"]},\"38\":{\"h\":\"面试题\"},\"39\":{\"h\":\"获取链表有效节点个数（去除头节点） 新浪面试题\",\"t\":[\" public int getLength() { int length = 0; //计数器 if (head.next == null) { return length; } Node cur = head.next; while (cur != null) { length++; cur = cur.next; } return length; } \"]},\"40\":{\"h\":\"获取倒数K个节点 新浪面试题\",\"t\":[\" //从头遍历length-k个数据 public Node getLastK(int k) { //判空 if (head.next == null) { return null; } //获取链表长度，即上面获取有效节点个数 int length = getLength(); //判断k if (length < k || k < 1) { return null; } Node cur = head.next; //从头遍历length-k个数据即为倒数第K个 for (int i = 0; i < length - k; i++) { cur = cur.next; } return cur; } \"]},\"41\":{\"h\":\"数组反转 1-2-3 变成3-2-1 腾讯面试题\",\"t\":[\" public void reverse() { //判空 if (head.next == null || head.next.next == null) { return; } //辅助指针 Node cur = head.next; Node next = null; //当前节点的下一个节点 Node newHead = new Node(); //新头节点 //head-1-2-3 此时cur=1 while (cur != null) { next = cur.next; //next=2 3 null cur.next = newHead.next; //1-null 2-1-null 3-2-1-null newHead.next = cur; //head-1-null head-2-1-null head-3-2-1-null cur = next; //cur=2 cur=3 } head.next = newHead.next; } \"]},\"42\":{\"h\":\"逆序打印 百度面试题\",\"t\":[\" //方法一 先逆序再遍历打印 先reverse再遍历 //方法二 使用栈（下面方法） public void reversePrint() { if (head.next == null) { return; } Stack<Node> stack = new Stack<>(); //栈 先进后出 Node cur = head.next; while (cur != null) { stack.push(cur); //入栈 cur = cur.next; //后移 } //节点全部正序入栈 栈先进后出 遍历栈即可得到逆序 stack.forEach(System.out::println); } \"]},\"43\":{\"h\":\"完整代码\",\"t\":[\"public class SingleLinkedList { private Node head = new Node(); //头节点 不存数据 //顺序添加节点 public void add(Node node) { //将最后节点的next指向新的节点 Node temp = head; while (true) { //最后一个节点 if (temp.next == null) { break; } //没找到最后一个节点就后移 temp = temp.next; } temp.next = node; } //按照年纪从小到大插入节点 例如2应该插入1-》3之间变成1-》2-》3 //如果已经存在则添加失败 public void addByAge(Node node) { Node temp = head; boolean isExist = false;//判断是否已经存在 while (true) { if (temp.next == null) { //链表尾部 break; } if (temp.next.age > node.age) { //找到位置 break; } else if (temp.next.age == node.age) { //已经存在 isExist = true; break; } temp = temp.next; } if (isExist) { //已经存在 System.out.println(\\\"插入失败，已经存在！！\\\"); return; } //2-》3 node.next = temp.next; //1-》2 temp.next = node; } //删除节点 按照age 1-2-3变成1-3 public void delByAge(int age) { Node temp = head; boolean isFind = false;//判断是否找到 while (true) { if (temp.next == null) { //链表尾部 break; } if (temp.next.age == age) { //找到位置 isFind = true; break; } temp = temp.next; } if (!isFind) { //不存在 System.out.println(\\\"删除失败，数据不存在！！\\\"); return; } temp.next = temp.next.next; } //根据Age修改节点 public void editByAge(Node node) { if (head.next == null) { System.out.println(\\\"链表为空！\\\"); return; } Node temp = head.next; boolean isFind = false;//判断是否找到 while (true) { if (temp == null) { break; } if (temp.age == node.age) { isFind = true; break; } temp = temp.next; } if (!isFind) { System.out.println(\\\"修改失败，数据不存在！！\\\"); return; } temp.name = node.name; } //显示链表 public void showList() { //判空 if (head.next == null) { return; } Node temp = head.next; while (true) { if (temp == null) { break; } System.out.println(temp); temp = temp.next; } } //获取倒数K个节点 新浪面试题 //遍历length-k public Node getLastK(int k) { //判空 if (head.next == null) { return null; } int length = getLength(); //判断k if (length < k || k < 1) { return null; } Node cur = head.next; for (int i = 0; i < length - k; i++) { cur = cur.next; } return cur; } //获取链表有效节点个数（去除头节点） 新浪面试题 public int getLength() { int length = 0; if (head.next == null) { return length; } Node cur = head.next; while (cur != null) { length++; cur = cur.next; } return length; } //数组反转 1-2-3 变成3-2-1 腾讯面试题 public void reverse() { if (head.next == null || head.next.next == null) { return; } //辅助指针 Node cur = head.next; Node next = null; //当前节点的下一个节点 Node newHead = new Node(); //head-1-2-3 cur=1 while (cur != null) { next = cur.next; //next=2 3 null cur.next = newHead.next; //1-null 2-1-null 3-2-1-null newHead.next = cur; //head-1-null head-2-1-null head-3-2-1-null cur = next; //cur=2 cur=3 } head.next = newHead.next; } //逆序打印 百度面试题 //方法一 先逆序再遍历打印 //方法二 使用栈 public void reversePrint() { if (head.next == null) { return; } Stack<Node> stack = new Stack<>(); Node cur = head.next; while (cur != null) { stack.push(cur); cur = cur.next; } stack.forEach(System.out::println); } public static void main(String[] args) { Node node1 = new Node(18, \\\"小一\\\"); Node node2 = new Node(20, \\\"大二\\\"); Node node3 = new Node(30, \\\"中三\\\"); SingleLinkedList list = new SingleLinkedList(); list.add(node1); list.add(node2); list.add(node3); list.showList(); Node node4 = new Node(10, \\\"little four\\\"); list.addByAge(node4); System.out.println(); list.showList(); Node node3_1 = new Node(30, \\\"大大大啊三\\\"); list.editByAge(node3_1); System.out.println(); list.showList(); list.delByAge(18); System.out.println(); list.showList(); System.out.println(\\\"长度：\\\" + list.getLength()); System.out.println(\\\"倒数第二个：\\\" + list.getLastK(2)); //反转 //list.reverse(); //list.showList(); list.reversePrint(); } } class Node { public int age; public String name; public Node next; //指向下一个节点 public Node() { } public Node(int age, String name) { this.age = age; this.name = name; } @Override public String toString() { return \\\"Node{\\\" + \\\"age=\\\" + age + \\\", name='\\\" + name + '\\\\'' + '}'; } } \"]},\"44\":{\"c\":[\"链表\"]},\"45\":{\"h\":\"数组队列\"},\"46\":{\"h\":\"队列介绍\",\"t\":[\"队列是一个有序列表，可以用数组或是链表来实现\",\"遵循先入先出的原则。即：先存入队列的数据，要先取出，后存入的要后取出\",\"示意图：(使用数组模拟队列示意图)， 如饭店排号系统，先来先排，轮到你你先吃，晚来的继续排队，叫到号才可以吃\",\"示意图\"]},\"47\":{\"h\":\"数组模拟队列思路\",\"t\":[\"队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图, 其中maxSize 是该队列的最大容量\",\"因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标\",\"front 会随着数据输出而改变，而 rear 则是随着数据输入而改变\",\"当我们将数据存入队列时称为addQueue，addQueue 的处理需要有以下几个步骤：\",\"将尾指针往后移：rear+1\",\"当队列空： front == rear\",\"若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据，即队列满：rear == maxSize - 1\"]},\"48\":{\"h\":\"代码实现\"},\"49\":{\"h\":\"初始化\",\"t\":[\" private int maxSize; //数组最大容量 private int front; //头指针 private int rear; //尾指针 private int[] arr; //队列存储 //初始化队列 public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = -1; //指向队列头的前一个位置（规约） rear = -1; //指向队列最后一个数据（规约） } \",\"头指针front指向队列头的前一个位置\",\"尾指针rear指向最后一个数据\"]},\"50\":{\"h\":\"队空\",\"t\":[\" //队列空 rear == front public boolean isEmpty() { return rear == front; } \"]},\"51\":{\"h\":\"队满\",\"t\":[\" //队列满 rear == maxSize - 1 public boolean isFull() { return rear == maxSize - 1; } \"]},\"52\":{\"h\":\"添加数据（入队）\",\"t\":[\" //添加数据 public void addQueue(int num) { //判断队满 if (isFull()) { System.out.println(\\\"队列满不能再继续添加！\\\"); return; } rear++; arr[rear] = num; } \"]},\"53\":{\"h\":\"出队\",\"t\":[\" //出队列 public int getQueue() { //判断队空 if (isEmpty()) { throw new RuntimeException(\\\"队列为空！\\\"); } front++; return arr[front]; } \"]},\"54\":{\"h\":\"显示队列头数据（不取出）\",\"t\":[\" //显示队列头数据（不取出） public int headQueue() { //判断队空 if (isEmpty()) { throw new RuntimeException(\\\"队列为空！\\\"); } return arr[front + 1]; } \"]},\"55\":{\"h\":\"完整代码\",\"t\":[\"class ArrayQueue { private int maxSize; //数组最大容量 private int front; //头指针 private int rear; //尾指针 private int[] arr; //队列存储 //初始化队列 public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = -1; //指向队列头的前一个位置（规约） rear = -1; //指向队列最后一个数据（规约） } //队列满 rear == maxSize - 1 public boolean isFull() { return rear == maxSize - 1; } //队列空 rear == front public boolean isEmpty() { return rear == front; } //添加数据 public void addQueue(int num) { //判断队满 if (isFull()) { System.out.println(\\\"队列满不能再继续添加！\\\"); return; } rear++; arr[rear] = num; } //出队列 public int getQueue() { //判断队空 if (isEmpty()) { throw new RuntimeException(\\\"队列为空！\\\"); } front++; return arr[front]; } //显示所有数据 public void showQueue() { //判断队空 if (isEmpty()) { System.out.println(\\\"队列为空！\\\"); return; } for (int i = front + 1; i <= rear; i++) { System.out.printf(\\\"%d\\\\t\\\", arr[i]); } System.out.println(); } //显示队列头数据（不取出） public int headQueue() { //判断队空 if (isEmpty()) { throw new RuntimeException(\\\"队列为空！\\\"); } return arr[front + 1]; } public static void main(String[] args) { ArrayQueue arrayQueue = new ArrayQueue(4); arrayQueue.addQueue(5); arrayQueue.addQueue(7); arrayQueue.addQueue(2); arrayQueue.showQueue(); int head = arrayQueue.headQueue(); System.out.println(\\\"队列首部数据：\\\" + head); arrayQueue.addQueue(1); arrayQueue.showQueue(); int num = arrayQueue.getQueue(); System.out.println(\\\"出队：\\\" + num); arrayQueue.showQueue(); } } \"]},\"56\":{\"h\":\"问题及解决方案\",\"t\":[\"目前数组使用一次就不能用， 没有达到复用的效果\",\"将这个数组使用算法，改进成一个环形的队列 取模：%\"]},\"57\":{\"c\":[\"数组\",\"队列\"]},\"58\":{\"h\":\"环形队列\",\"t\":[\"对前面的数组模拟队列的优化，充分利用数组，因此将数组看做是一个环形的。(通过取模的方式来实现即可)\"]},\"59\":{\"h\":\"分析说明\",\"t\":[\"尾索引的下一个为头索引时表示队列满，因为将队列容量空出一个作为约定（rear指向最后一个数据后一个位置），这个在做判断队列满的时候需要注意\",\"(rear + 1) % maxSize == front\",\"队列空：rear == front\",\"示意图\",\"示意图\",\"front不再指向队列头部数据前一个位置，而是指向头一个数据，初始化为0\",\"rear不再指向队列尾部数据，而是指向尾部数据下一个位置，初始化为0\",\"队满： (rear + 1) % maxSize == front\",\"队空：rear == front\",\"队列中数据个数：（rear + maxSize - front）% maxSize\"]},\"60\":{\"h\":\"代码实现\"},\"61\":{\"h\":\"初始化\",\"t\":[\" private int maxSize; //数组最大容量 private int front; //头指针 指向队列第一个数据 private int rear; //尾指针 指向队列最后一个数据的后一个位置 private int[] arr; //队列存储 public CircleArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = 0; //指向队列头的位置（规约） rear = 0; //指向队列最后一个数据的后一个位置（规约） } \"]},\"62\":{\"h\":\"队空\",\"t\":[\" //队列空 rear == front public boolean isEmpty() { return rear == front; } \"]},\"63\":{\"h\":\"队满\",\"t\":[\" //队列满 (rear + 1) % maxSize == front public boolean isFull() { return (rear + 1) % maxSize == front; } \"]},\"64\":{\"h\":\"添加数据\",\"t\":[\" //添加数据 public void addQueue(int num) { //判断队满 if (isFull()) { System.out.println(\\\"队列满不能再继续添加！\\\"); return; } arr[rear] = num; //后移 rear = (rear + 1) % maxSize; } \"]},\"65\":{\"h\":\"出队\",\"t\":[\" //出队列 public int getQueue() { //判断队空 if (isEmpty()) { throw new RuntimeException(\\\"队列为空！\\\"); } int num = arr[front]; //后移 front = (front + 1) % maxSize; return num; } \"]},\"66\":{\"h\":\"有效数据个数\",\"t\":[\" //队列有效数据个数 public int size() { return (rear + maxSize - front) % maxSize; } \"]},\"67\":{\"h\":\"完整代码\",\"t\":[\"public class CircleArrayQueue { private int maxSize; //数组最大容量 private int front; //头指针 指向队列第一个数据 private int rear; //尾指针 指向队列最后一个数据的后一个位置 private int[] arr; //队列存储 public CircleArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; front = 0; //指向队列头的位置（规约） rear = 0; //指向队列最后一个数据的后一个位置（规约） } //队列满 (rear + 1) % maxSize == front public boolean isFull() { return (rear + 1) % maxSize == front; } //队列空 rear == front public boolean isEmpty() { return rear == front; } //添加数据 public void addQueue(int num) { //判断队满 if (isFull()) { System.out.println(\\\"队列满不能再继续添加！\\\"); return; } arr[rear] = num; //后移 rear = (rear + 1) % maxSize; } //出队列 public int getQueue() { //判断队空 if (isEmpty()) { throw new RuntimeException(\\\"队列为空！\\\"); } int num = arr[front]; //后移 front = (front + 1) % maxSize; return num; } //显示所有数据 public void showQueue() { //判断队空 if (isEmpty()) { System.out.println(\\\"队列为空！\\\"); return; } int size = size(); for (int i = front; i < front + size; i++) { int index = i % maxSize; System.out.printf(\\\"%d\\\\t\\\", arr[index]); } System.out.println(); } //队列有效数据个数 public int size() { return (rear + maxSize - front) % maxSize; } //显示队列头数据（不取出） public int headQueue() { //判断队空 if (isEmpty()) { throw new RuntimeException(\\\"队列为空！\\\"); } return arr[front]; } public static void main(String[] args) { CircleArrayQueue queue = new CircleArrayQueue(4); //最多装3个数据 留下一个空位 queue.addQueue(5); queue.addQueue(7); queue.showQueue(); int head = queue.headQueue(); System.out.println(\\\"队列首部数据：\\\" + head); queue.addQueue(1); queue.showQueue(); int num = queue.getQueue(); System.out.println(\\\"出队：\\\" + num); queue.showQueue(); queue.addQueue(8); queue.showQueue(); } } \"]},\"68\":{\"c\":[\"数组\",\"队列\"]},\"69\":{\"h\":\"递归--迷宫、八皇后\"},\"70\":{\"h\":\"概念\",\"t\":[\"简单的说: 递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂的问题，同时可以让代码变得简洁\"]},\"71\":{\"h\":\"实际问题\",\"t\":[\"各种数学问题：八 皇后问题 ,，汉诺塔,，阶乘问题，迷宫问题,，球和篮子的问题\",\"各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等\",\"将用栈解决的问题-->递归代码比较简洁\"]},\"72\":{\"h\":\"迷宫问题\",\"t\":[\"给定一个迷宫，指明起点和终点，找出从起点出发到终点的有效可行路径，就是迷宫问题（maze problem）\",\"如下如图，1代表墙壁，0代表可走的路，4代表出口，假设从(1,1)开始出发，寻找一个路径到达出口即算完成，路径为2标识的\",\"1 1 1 1 1 1 1 1 0 0 0 0 0 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 4 1 1 1 1 1 1 1 1 || 1 1 1 1 1 1 1 1 2 0 0 0 0 1 1 2 2 2 0 0 1 1 1 1 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 0 0 1 1 0 0 2 2 2 1 1 1 1 1 1 1 1 \"]},\"73\":{\"h\":\"代码实现\"},\"74\":{\"h\":\"初始化地图\",\"t\":[\"创建一个8x7的迷宫如上图所示，四周模拟围墙全部设置为1，(3,1)和(3,2)也是墙设置为1\",\" //初始化地图 private static int[][] initMap() { //使用二维数组模拟迷宫 int[][] map = new int[8][7]; //数字1模拟墙 上下全部置为1 for (int i = 0; i < 7; i++) { map[0][i] = 1; map[7][i] = 1; } //左右置为1 for (int i = 0; i < 8; i++) { map[i][0] = 1; map[i][6] = 1; } //设置挡板墙 map[3][1] = 1; map[3][2] = 1; return map; } \"]},\"75\":{\"h\":\"打印地图\",\"t\":[\" //打印地图 private static void printMap(int[][] map) { for (int i = 0; i < 8; i++) { for (int j = 0; j < 7; j++) { System.out.printf(\\\"%d\\\\t\\\", map[i][j]); } System.out.println(); } } \"]},\"76\":{\"h\":\"迷宫求解\",\"t\":[\" /** * 使用递归回溯给小球找路 * 出发点(i,j) * 能到达右下角map[6][5]则通路找到 * 约定：当map[m][n]=0表示没走过 为1表示墙 为2表示通路可以走 3表示已经走过但是走不通 * 走迷宫时，需要定一个策略，下-右-上-左 走不通就再回溯 * * @param map 地图 * @param i 从哪里开始找 * @param j 从哪里开始找 * @return 找到就返回true没有找到就是false 能到右下角则能找到即(6,5) */ public static boolean setWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) { //当前点还没走过 按策略走 下-右-上-左 map[i][j] = 2;//假设可以走通 置为2 if (setWay(map, i + 1, j)) { //向下走 return true; } else if (setWay(map, i, j + 1)) { //向右走 return true; } else if (setWay(map, i - 1, j)) { //向上走 return true; } else if (setWay(map, i, j - 1)) { //向左走 return true; } else { //说明该点走不通 置为3 map[i][j] = 3; return false; } } else { //如果不等于0可能是1、2、3 1墙 2走过的路 3死路 return false; } } } \"]},\"77\":{\"h\":\"完整代码\",\"t\":[\"public class MiGong { public static void main(String[] args) { int[][] map = initMap(); printMap(map); boolean isExit = setWay(map, 1, 1); System.out.println(\\\"能否走出迷宫：\\\" + isExit); printMap(map); } /** * 使用递归回溯给小球找路 * 出发点(i,j) * 能到达右下角map[6][5]则通路找到 * 约定：当map[m][n]=0表示没走过 为1表示墙 为2表示通路可以走 3表示已经走过但是走不通 * 走迷宫时，需要定一个策略，下-右-上-左 走不通就再回溯 * * @param map 地图 * @param i 从哪里开始找 * @param j 从哪里开始找 * @return 找到就返回true没有找到就是false 能到右下角则能找到即(6,5) */ public static boolean setWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; } else { if (map[i][j] == 0) { //当前点还没走过 按策略走 下-右-上-左 map[i][j] = 2;//假设可以走通 置为2 if (setWay(map, i + 1, j)) { //向下走 return true; } else if (setWay(map, i, j + 1)) { //向右走 return true; } else if (setWay(map, i - 1, j)) { //向上走 return true; } else if (setWay(map, i, j - 1)) { //向左走 return true; } else { //说明该点走不通 置为3 map[i][j] = 3; return false; } } else { //如果不等于0可能是1、2、3 1墙 2走过的路 3死路 return false; } } } //初始化地图 private static int[][] initMap() { //使用二维数组模拟迷宫 int[][] map = new int[8][7]; //数字1模拟墙 上下全部置为1 for (int i = 0; i < 7; i++) { map[0][i] = 1; map[7][i] = 1; } //左右置为1 for (int i = 0; i < 8; i++) { map[i][0] = 1; map[i][6] = 1; } //设置挡板 map[3][1] = 1; map[3][2] = 1; return map; } //打印地图 private static void printMap(int[][] map) { for (int i = 0; i < 8; i++) { for (int j = 0; j < 7; j++) { System.out.printf(\\\"%d\\\\t\\\", map[i][j]); } System.out.println(); } } } \"]},\"78\":{\"h\":\"八皇后问题\",\"t\":[\"八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法(92种)\"]},\"79\":{\"h\":\"思路分析\",\"t\":[\"第一个皇后先放第一行第一列\",\"第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适\",\"继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确解\",\"当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.\",\"然后回头继续第一个皇后放第二列，后面继续循环执行 1、2、3、4 的步骤\",\"理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题。 arr[8] ={0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1 个皇后，放在第i+1行的第 val+1 列\"]},\"80\":{\"h\":\"算法实现\",\"t\":[\"public class EightQueue { int max = 8; //定义一共多少皇后 int[] array = new int[max]; int count = 0; //将皇后摆放的位置输出 private void print() { count++; for (int i : array) { System.out.printf(i + \\\" \\\"); } System.out.println(); } //检测皇后和已摆放皇后冲突 private boolean judge(int n) { for (int i = 0; i < n; i++) { //同一列 array[i] == array[n] //同一斜线 Math.abs(n - i) == Math.abs(array[n] - array[i]) 即斜率为1 //因为n在递增故不需要判断在同一行 if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) { return false; } } return true; } //放置第n个皇后 private void check(int n) { if (n == max) { //八个皇后已然放好 print(); return; } //依次放皇后并判断是否冲突 for (int i = 0; i < max; i++) { //先把当前的放到改行的第一列 array[n] = i; if (judge(n)) {//不冲突 //放n+1个 check(n + 1); } } } public static void main(String[] args) { EightQueue eightQueue = new EightQueue(); eightQueue.check(0); System.out.println(\\\"共 \\\" + eightQueue.count + \\\" 种解法\\\"); } } \"]},\"81\":{\"c\":[\"递归\"]},\"82\":{\"h\":\"稀疏数组\"},\"83\":{\"h\":\"需求\",\"t\":[\"编写的五子棋程序中，有存盘退出和续上盘的功能\",\"棋盘\",\"因为该二维数组的很多值是默认值 0, 因此记录了很多没有意义的数据，因此可以使用稀疏数组来记录信息\"]},\"84\":{\"h\":\"基本介绍\",\"t\":[\"当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组\",\"记录数组一共有几行几列，有多少个不同的值\",\"把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模\",\"稀疏数组\",\"即可以用 (N+1)x 3 数组来记录，其中 N 代表数组数据个数\",\"第一行第一列代表原始数组总行数，例如11*11的原始数组是11行\",\"第一行第二列代表原始数组总列数，例如11*11的原始数组是11列\",\"第一行第三列代表原始数组数据个数，例如原始数组只有两个数据1和2，因此记录为2，即为N\",\"下面N行的第一列代表数据在原始数组第几行，例如1位于（1，2）即记录为1\",\"下面N行的第二列代表数据在原始数组第几列，例如1位于（1，2）即记录为2\",\"下面N行的第三列代表数据在原始数组的值，例如1则记录为1，2则记录为2\"]},\"85\":{\"h\":\"代码实现\",\"t\":[\"二维数组转换为稀疏数组\",\"统计非0元素个数用于初始化稀疏数组\",\"根据非0元素个数构造N行填充数据\",\"稀疏数组还原为二维数组\",\"根据第一行数据初始化二维数组\",\"遍历稀疏数组填充二维数组\",\"public class SparseArray { public static void main(String[] args) { //原始二维数组 11*11 int[][] chessArr = new int[11][11]; //模拟棋盘 0:没有棋子 1 黑子 2 白子 chessArr[1][2] = 1; chessArr[2][3] = 2; //遍历输出原始二维数组 System.out.println(\\\"raw array:\\\"); printArray(chessArr); //将二维数组转稀疏数组 //遍历二位数组得到非0数据个数 int sum = 0; for (int i = 0; i < chessArr.length; i++) { for (int j = 0; j < chessArr[i].length; j++) if (chessArr[i][j] != 0) { sum++; } } System.out.println(\\\"chess num: \\\" + sum); //初始化稀疏数组 int[][] sparseArr = new int[sum + 1][3]; //第一行为数据在二维数组中的 总行数 总列数 总个数 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; //遍历二维数组 将非0数据添加进稀疏数组 //第一列记录行 第二列记录列 第三列记录值 int count = 0; //计数即N个数据N行 for (int i = 0; i < chessArr.length; i++) { for (int j = 0; j < chessArr[i].length; j++) if (chessArr[i][j] != 0) { count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr[i][j]; } } //遍历输出稀疏数组 System.out.println(\\\"sparse array:\\\"); printArray(sparseArr); //稀疏数组还原二维数组 int[][] rebuildArray = new int[sparseArr[0][0]][sparseArr[0][1]]; //第二行开始遍历 for (int i = 1; i < sparseArr.length; i++) { rebuildArray[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; } //遍历输出原始二维数组 System.out.println(\\\"rebuild array:\\\"); printArray(rebuildArray); } private static void printArray(int[][] chessArr) { for (int[] row : chessArr) { for (int chess : row) { System.out.printf(\\\"%d\\\\t\\\", chess); } System.out.println(); } } } \"]},\"86\":{\"c\":[\"数组\"]},\"87\":{\"h\":\"前缀、中缀、后缀表达式\"},\"88\":{\"h\":\"前缀、中缀、后缀表达式\"},\"89\":{\"h\":\"中缀表达式\",\"t\":[\"首先，中缀表达式的这个“缀”指运算符在两个操作数的位置。中缀表达式其实就是我们常用的算术表达式，比如 2 + 9 - (32 * (19 - 4) +14)，我们很容易就可以得到计算结果，但是对于计算机来说，它们就得对各个运算符进行优先级比较以及弹栈和入栈等操作，其实计算机对于前缀表达式和后缀表达式更容易理解\"]},\"90\":{\"h\":\"前缀表达式\",\"t\":[\"前缀表达式，也称波兰式，指运算符处于两个操作数的前面，比如 2 + 3，那么前缀表达式就是 + 2 3；对于复杂点的表达式，如 13 * ((3 + 8) * 4)，前缀表达式为 * 13 * + 3 8 4，后续分析怎么转换\"]},\"91\":{\"h\":\"后缀表达式\",\"t\":[\"也称逆波兰式，指运算符处于两操作数后面，比如 2 + 3，后缀表达式为 2 3 +；对于复杂点的表达式，如 13 * ((3 + 8) * 4)，后缀表达式为 13 3 8 + 4 * *，后续会讲怎么转换\"]},\"92\":{\"h\":\"前缀表达式求值\",\"t\":[\"从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算(栈顶元素 和 次顶元素)，并将结果入栈：重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果\",\"例如: (3+4)x5-6 对应的前缀表达式就是-x+3456，针对前缀表达式求值步骤如下：\",\"从右至左扫描，将6、5、4、3压入堆栈\",\"遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈\",\"接下来是x运算符，因此弹出7和5，计算出7x5=35，将35入栈\",\"最后是-运算符，计算出35-6的值，即29，由此得出最终结果（注意这里是栈顶元素-次顶元素）\"]},\"93\":{\"h\":\"中缀表达式求值\",\"t\":[\"计算思路对于一个中缀表达式字符串36-2*6-200：使用两个栈（一个存放数字一个存放符号）\",\"通过一个index 值（索引），来遍历我们的表达式\",\"如果我们发现是一个数字，就直接入数栈（多位数字需要拼接之后再入）\",\"如果发现扫描到是一个符号，就分如下情况\",\"如果发现当前的符号栈为空，就直接入栈\",\"如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数，在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈\",\"当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行\",\"最后在数栈只有一个数字，就是表达式的结果\",\"对于思路不必理解记住流程即可（注意运算时是次顶元素-栈顶元素，这一点与前缀表达式求值相反）\"]},\"94\":{\"h\":\"定义几个工具方法\",\"t\":[\"priority：用于判断优先级，其中乘除优先级大于加减\",\"isOper：判断字符是操作符还是数字\",\"cal：进行加减乘除计算（对于中缀表达式弹出栈顶的两个数字，在进行减法和除法时是次栈-栈顶和次栈/栈顶，因此是num2-num1、num2/num1）\",\"peek：与pop不同，peek只得到数字而不弹出，即指针不移动\",\" //定义运算优先级 假定只有+ - * / //数字越大优先级越高 public int priority(int oper) { if (oper == '*' || oper == '/') { return 2; } else if (oper == '+' || oper == '-') { return 1; } else { return 0; } } //判断是否是运算符 public boolean isOper(char val) { return val == '+' || val == '-' || val == '*' || val == '/'; } //计算方法 public int cal(int num1, int num2, int oper) { int res = 0; switch (oper) { case '+': res = num1 + num2; break; case '-': num1 = num1 < 0 ? -num1 : num1; res = num2 - num1; break; case '*': res = num1 * num2; break; case '/': res = num2 / num1; break; default: break; } return res; } //返回栈顶的值但不出栈 public int peek() { return stack[top]; } \"]},\"95\":{\"h\":\"完整代码\",\"t\":[\"首先定义两个栈以及扫描索引\",\"分割表达式字符串的每一个字符\",\"如果是数字则进行判断是否是多位数，如1+2则1和2是单个数，100+20则是多位数，第一个字符是1，仍需要获得00进行拼接成100，所以数字时需要判断直到遇到运算符停止，然后将拼接的数字直接入数栈\",\"如果是操作符就进行比较，如果当前的操作符的优先级小于或者等于栈顶的操作符，就需要从数栈中 pop 出两个数，同时再从符号栈中 pop 出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈；如果优先级大于则直接入符号栈\",\"当表达式扫描完毕，就顺序的从 数栈和符号栈中 pop 出相应的数和符号，并运行\",\"最后留在数栈的元素就是计算结果\",\"public class Calculator { public static void main(String[] args) { String expression = \\\"36-2*6-200\\\"; //数字栈 CalStack numStack = new CalStack(20); //操作符栈 CalStack operStack = new CalStack(20); int index = 0; //扫描索引 int num1; //数字栈pop出的第一个数字 int num2;//数字栈pop出的第二个数字 int res; //计算结果 int oper; char ch;//扫描得到的char StringBuilder keepNum = new StringBuilder();//用于拼接多位数 while (true) { ch = expression.substring(index, index + 1).charAt(0); //判断ch是数字还是符号 if (operStack.isOper(ch)) { //运算符 if (!operStack.isEmpty()) { //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈顶的操作符, 就需要从数栈中 pop 出两个数 //再从符号栈中 pop 出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈 if (operStack.priority(ch) <= operStack.priority(operStack.peek())) { num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res); operStack.push(ch); } else { //如果优先级大于则直接入符号栈 operStack.push(ch); } } else { //如果为空则入栈 operStack.push(ch); } } else { //单位数字直接入栈 多位数需要向后看遇到符号停止 拼接数字 keepNum.append(ch); while (true) { if (index + 1 >= expression.length() || operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) { break; } index++; ch = expression.substring(index, index + 1).charAt(0); keepNum.append(ch); } numStack.push(Integer.parseInt(keepNum.toString())); keepNum = new StringBuilder(); } index++; if (index >= expression.length()) { break; } } //当表达式扫描完毕，就顺序的从 数栈和符号栈中 pop 出相应的数和符号，并运行 while (true) { if (operStack.isEmpty()) { break; } num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); numStack.push(res); } System.out.println(\\\"结果：\\\" + numStack.pop()); } } class CalStack { private int maxSize; //栈大小 private int[] stack; //数据存储 private int top = -1; //表示栈顶，初始化-1 public CalStack(int maxSize) { this.maxSize = maxSize; stack = new int[maxSize]; } //栈满 public boolean isFull() { return top == maxSize - 1; } //栈空 public boolean isEmpty() { return top == -1; } //入栈 public void push(int num) { if (isFull()) { System.out.println(\\\"栈已经满了\\\"); return; } top++; stack[top] = num; } //出栈 public int pop() { if (isEmpty()) { throw new RuntimeException(\\\"栈为空\\\"); } //取出数据 int num = stack[top]; top--; return num; } //遍历栈 自顶向下遍历 public void list() { if (isEmpty()) { throw new RuntimeException(\\\"栈为空\\\"); } for (int i = top; i >= 0; i--) { System.out.println(stack[i]); } } //定义运算优先级 假定只有+ - * / //数字越大优先级越高 public int priority(int oper) { if (oper == '*' || oper == '/') { return 2; } else if (oper == '+' || oper == '-') { return 1; } else { return 0; } } //判断是否是运算符 public boolean isOper(char val) { return val == '+' || val == '-' || val == '*' || val == '/'; } //计算方法 public int cal(int num1, int num2, int oper) { int res = 0; switch (oper) { case '+': res = num1 + num2; break; case '-': num1 = num1 < 0 ? -num1 : num1; res = num2 - num1; break; case '*': res = num1 * num2; break; case '/': res = num2 / num1; break; default: break; } return res; } //返回栈顶的值但不出栈 public int peek() { return stack[top]; } } \"]},\"96\":{\"h\":\"后缀表达式求值\",\"t\":[\"从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算(次顶元素 和 栈顶元素)，并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果\",\"例如:(3+4)x5-6 对应的前缀表达式就是34+5x6-，针对后缀表达式求值步骤如下：\",\"从左至右扫描，将3和4压入堆栈\",\"遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈\",\"将5入栈\",\"接下来是x运算符，因此弹出5和7，计算出7x5=35，将35入栈\",\"将6入栈\",\"最后是-运算符，计算出35-6的值，即29，由此得出最终结果\",\"注意这里35-6是次顶-栈顶，与中缀相同、与前缀不同\",\"对于一个处理成[3，4，+，5，x，6，-]列表的表达式计算如下\",\"数字直接入栈\",\"运算符则pop两个数字用当前运算符进行计算，然后将计算结果入栈\",\" /** * 1．从左至右扫描，将 3 和 4 压入堆栈； * 2．遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得7，再将7 入栈；3．将 5 入栈； * 4．接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈； * 5．将 6 入栈； * 6．最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果 */ public static void suffixCal(List<String> exp) { Stack<String> stack = new Stack<>(); int num1, num2, res = 0; for (String s : exp) { //正则表达式表示是数字 if (s.matches(\\\"\\\\\\\\d+\\\")) { stack.push(s); } else { //弹出栈顶和次栈顶数字 num1 = Integer.parseInt(stack.pop()); num2 = Integer.parseInt(stack.pop()); if (s.equals(\\\"+\\\")) { res = num1 + num2; } else if (s.equals(\\\"-\\\")) { res = num2 - num1; } else if (s.equals(\\\"*\\\")) { res = num2 * num1; } else if (s.equals(\\\"/\\\")) { res = num2 / num1; } //入栈 stack.push(res + \\\"\\\"); } } //最后留在stack中就是结果 System.out.println(\\\"结果：\\\" + stack.pop()); } \",\"可以看出来前缀、后缀表达式求值比中缀简单得多，而计算机也更擅长处理前缀和后缀，而后缀是从左到右扫描符合习惯，下面将介绍如何将中缀表达式（人熟悉）转后缀表达式（计算机熟悉）\"]},\"97\":{\"h\":\"中缀表达式转后缀表达式\",\"t\":[\"具体步骤如下：\",\"初始化两个栈：运算符栈s1和储存中间结果的栈s2\",\"从左至右扫描中缀表达式\",\"遇到数时，将其压s2\",\"遇到运算符时，比较其与s1栈顶运算符的优先级： \",\"如果s1为空，或栈顶运算符为左括号\\\"(\\\"，则直接将此运算符入栈\",\"否则，若优先级比栈顶运算符的高，也将运算符压入s1\",\"否则，将s1栈顶的运算符弹出并压入到s2中，再次转到4.1与s1中新的栈顶运算符相比较\",\"遇到括号时： \",\"如果是左括号\\\"(\\\"，则直接压入s1\",\"如果是右括号\\\")\\\"，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃\",\"重复步骤2至5，直到表达式的最右边\",\"将s1中剩余的运算符依次弹出并压入s2\",\"依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式\",\"举例\"]},\"98\":{\"h\":\"代码实现\",\"t\":[\"首先第一步将(3+4)x5-6 转换成[(,3,+,4,+,),x,5,-,6]\",\"再执行上述流程，但使用的是一个栈s1一个List s2，栈还得弹出，List可以直接遍历方便一些\",\"public class PolandNotation { public static void main(String[] args) { //(3+4)*5-6 => 3 4 + 5 * 6 - String exp = \\\"(3+4)*5-6\\\"; List<String> expList = stringToList(exp); //中缀表达式转后缀表达式 List<String> strings = parseSuffixExp(expList); //strings 3 4 + 5 * 6 - suffixCal(strings); } /** * 将(3+4)*5-6 转换成[(,3,+,4,+,),*,5,-,6] * * @param s * @return */ public static List<String> stringToList(String s) { ArrayList<String> arrayList = new ArrayList<>(); int index = 0; StringBuilder str; char c; do { //如果c是非数字加入arrayList if ((c = s.charAt(index)) < 48 || (c = s.charAt(index)) > 57) { arrayList.add(String.valueOf(c)); index++; } else { str = new StringBuilder(); //c是数字 则拼接再入栈，遇到操作符停止 while (index < s.length() && (c = s.charAt(index)) >= 48 && (c = s.charAt(index)) <= 57) { str.append(c); index++; } arrayList.add(str.toString()); } } while (index < s.length()); return arrayList; } /** * 中缀表达式转后缀表达式 * * @param stringList * @return */ public static List<String> parseSuffixExp(List<String> stringList) { //在这里不用两个栈 而是用一个栈一个list处理 Stack<String> s1 = new Stack<>(); List<String> s2 = new ArrayList<>(); for (String str : stringList) { if (str.matches(\\\"\\\\\\\\d+\\\")) { //str是数字入s2 s2.add(str); } else if (str.equals(\\\"(\\\")) { //左括号直接入s1 s1.push(str); } else if (str.equals(\\\")\\\")) { //右括号 弹出栈顶元素压入s2 直到遇到左括号为止 同时将这一对括号丢弃 while (!s1.peek().equals(\\\"(\\\")) { s2.add(s1.pop()); } //！！！丢弃左括号 s1.pop(); } else { //当str优先级小于等于s1栈顶的 将s1栈顶弹出压入s2 while (!s1.isEmpty() && priority(str) <= priority(s1.peek())) { s2.add(s1.pop()); } //将str压入s1 s1.add(str); } } //将s1剩余运算符加入s2 while (!s1.isEmpty()) { s2.add(s1.pop()); } return s2; } public static int priority(String oper) { if (oper.equals(\\\"*\\\") || oper.equals(\\\"/\\\")) { return 2; } else if (oper.equals(\\\"+\\\") || oper.equals(\\\"-\\\")) { return 1; } else { return 0; } } /** * 1．从左至右扫描，将 3 和 4 压入堆栈； * 2．遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得7，再将7 入栈；3．将 5 入栈； * 4．接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈； * 5．将 6 入栈； * 6．最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果 */ public static void suffixCal(List<String> exp) { Stack<String> stack = new Stack<>(); int num1, num2, res = 0; for (String s : exp) { //正则表达式表示是数字 if (s.matches(\\\"\\\\\\\\d+\\\")) { stack.push(s); } else { //弹出栈顶和次栈顶数字 num1 = Integer.parseInt(stack.pop()); num2 = Integer.parseInt(stack.pop()); if (s.equals(\\\"+\\\")) { res = num1 + num2; } else if (s.equals(\\\"-\\\")) { res = num2 - num1; } else if (s.equals(\\\"*\\\")) { res = num2 * num1; } else if (s.equals(\\\"/\\\")) { res = num2 / num1; } //入栈 stack.push(res + \\\"\\\"); } } //最后留在stack中就是结果 System.out.println(\\\"结果：\\\" + stack.pop()); } } \"]},\"99\":{\"c\":[\"栈\"]},\"100\":{\"h\":\"栈\"},\"101\":{\"h\":\"栈的介绍\",\"t\":[\"栈的英文为(stack)\",\"栈是一个 先入后出(FILO-First In Last Out) 的有序列表\",\"栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)\",\"根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除\",\"图解方式说明 出栈(pop) 和 入栈(push) 的概念\",\"出栈入栈\",\"可理解为一个弹夹从顶部压入子弹到底部，发射从顶部开始弹出（FILO）\"]},\"102\":{\"h\":\"栈的应用场景\",\"t\":[\"子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中\",\"处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中\",\"表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)\",\"二叉树的遍历\",\"图形的深度优先(depth 一 first)搜索法\"]},\"103\":{\"h\":\"数组模拟栈\"},\"104\":{\"h\":\"初始化\",\"t\":[\"栈需要指定大小maxSize，在这里使用数组存储数据，同时设置栈顶指针top初始化为-1\",\"public class ArrayStack { private int maxSize; //栈大小 private int[] stack; //数据存储 private int top = -1; //表示栈顶，初始化-1 public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[maxSize]; } } \"]},\"105\":{\"h\":\"栈满\",\"t\":[\"当栈满时top位于最顶部即maxSize-1（因为索引从0开始）\",\" //栈满 public boolean isFull() { return top == maxSize - 1; } \"]},\"106\":{\"h\":\"栈空\",\"t\":[\" //栈空 public boolean isEmpty() { return top == -1; } \"]},\"107\":{\"h\":\"入栈Push\",\"t\":[\"先将栈顶指针向上移动一位，再压入一个数据，这样top始终指向顶部数据\",\" //入栈 public void push(int num) { if (isFull()) { System.out.println(\\\"栈已经满了\\\"); return; } top++; stack[top] = num; } \"]},\"108\":{\"h\":\"出栈Pop\",\"t\":[\"Pop类似于弹夹弹出子弹，需要先取出数据再将栈顶top指针向下移动\",\"如果先移动再取出则取出的就不是栈顶数据而是次栈顶数据了\",\" //出栈 public int pop() { if (isEmpty()) { throw new RuntimeException(\\\"栈为空\\\"); } //取出数据 int num = stack[top]; top--; return num; } \"]},\"109\":{\"h\":\"遍历\",\"t\":[\" //遍历栈 自顶向下遍历 public void list() { if (isEmpty()) { throw new RuntimeException(\\\"栈为空\\\"); } for (int i = top; i >= 0; i--) { System.out.println(stack[i]); } } \"]},\"110\":{\"h\":\"完整代码\",\"t\":[\"public class ArrayStack { private int maxSize; //栈大小 private int[] stack; //数据存储 private int top = -1; //表示栈顶，初始化-1 public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[maxSize]; } //栈满 public boolean isFull() { return top == maxSize - 1; } //栈空 public boolean isEmpty() { return top == -1; } //入栈 public void push(int num) { if (isFull()) { System.out.println(\\\"栈已经满了\\\"); return; } top++; stack[top] = num; } //出栈 public int pop() { if (isEmpty()) { throw new RuntimeException(\\\"栈为空\\\"); } //取出数据 int num = stack[top]; top--; return num; } //遍历栈 自顶向下遍历 public void list() { if (isEmpty()) { throw new RuntimeException(\\\"栈为空\\\"); } for (int i = top; i >= 0; i--) { System.out.println(stack[i]); } } public static void main(String[] args) { ArrayStack arrayStack = new ArrayStack(5); arrayStack.push(1); arrayStack.push(5); arrayStack.push(3); arrayStack.push(2); arrayStack.pop(); arrayStack.push(8); arrayStack.list(); } } \"]},\"111\":{\"h\":\"链表模拟栈\"},\"112\":{\"h\":\"定义Node节点\",\"t\":[\"class Node { public int value; public Node next; public Node() { } public Node(int value) { this.value = value; } } \"]},\"113\":{\"h\":\"初始化链表\",\"t\":[\"使用带头节点链表因此需要初始化head\",\"同时需要设置栈大小maxSize，count用于记录栈中元素个数\",\"public class LinkedListStack { private Node head = new Node();//头节点 private int maxSize; //栈大小 private int count = 0; //计数器 public LinkedListStack(int maxSize) { this.maxSize = maxSize; } } \"]},\"114\":{\"h\":\"满与空\",\"t\":[\"因为count作为计数器所以满与空只用判断count即可\",\"countmaxSize即为满，count0即为空\",\" //栈满 public boolean isFull() { return count == maxSize; } //栈空 public boolean isEmpty() { return count == 0; } \"]},\"115\":{\"h\":\"入栈Push\",\"t\":[\"头插发，始终将head的next节点设置为栈顶，例如head-1\",\"即对于新节点node，首先将node与1相连，即node.next=head.next\",\"再将head的下一个指向node，即head.next=node\",\"同时计数器+1\",\" //入栈 public void push(int num) { if (isFull()) { System.out.println(\\\"栈已经满了\\\"); return; } Node node = new Node(num); node.next = head.next; head.next = node; count++; } \"]},\"116\":{\"h\":\"出栈Pop\",\"t\":[\"删除head的next即可，同时count-1\",\" //出栈 public int pop() { if (isEmpty()) { throw new RuntimeException(\\\"栈为空\\\"); } //取出数据 Node next = head.next; head.next = next.next; count--; return next.value; } \"]},\"117\":{\"h\":\"遍历\",\"t\":[\" //遍历栈 自顶向下遍历 public void list() { if (isEmpty()) { throw new RuntimeException(\\\"栈为空\\\"); } Node temp = head.next; while (true) { if (temp == null) { break; } System.out.println(temp.value); temp = temp.next; } } \"]},\"118\":{\"h\":\"完整代码\",\"t\":[\"public class LinkedListStack { private Node head = new Node();//头节点 private int maxSize; //栈大小 private int count = 0; //计数器 public LinkedListStack(int maxSize) { this.maxSize = maxSize; } //栈满 public boolean isFull() { return count == maxSize; } //栈空 public boolean isEmpty() { return count == 0; } //入栈 public void push(int num) { if (isFull()) { System.out.println(\\\"栈已经满了\\\"); return; } Node node = new Node(num); node.next = head.next; head.next = node; count++; } //出栈 public int pop() { if (isEmpty()) { throw new RuntimeException(\\\"栈为空\\\"); } //取出数据 Node next = head.next; head.next = next.next; count--; return next.value; } //遍历栈 自顶向下遍历 public void list() { if (isEmpty()) { throw new RuntimeException(\\\"栈为空\\\"); } Node temp = head.next; while (true) { if (temp == null) { break; } System.out.println(temp.value); temp = temp.next; } } public static void main(String[] args) { LinkedListStack listStack = new LinkedListStack(5); listStack.push(1); listStack.push(5); listStack.push(3); listStack.push(2); listStack.pop(); listStack.push(8); listStack.list(); } } class Node { public int value; public Node next; public Node() { } public Node(int value) { this.value = value; } } \"]},\"119\":{\"c\":[\"栈\"]},\"120\":{\"h\":\"Article\"},\"121\":{\"h\":\"List\"},\"122\":{\"h\":\"Queue\"},\"123\":{\"h\":\"Recursion\"},\"124\":{\"h\":\"Sparsearray\"},\"125\":{\"h\":\"Stack\"}},\"dirtCount\":0,\"index\":[[\"始终将head的next节点设置为栈顶\",{\"1\":{\"115\":1}}],[\"满与空\",{\"0\":{\"114\":1}}],[\"搜索法\",{\"1\":{\"102\":1}}],[\"一\",{\"1\":{\"102\":1}}],[\"一个存放数字一个存放符号\",{\"1\":{\"93\":1}}],[\"图形的深度优先\",{\"1\":{\"102\":1}}],[\"图解方式说明\",{\"1\":{\"101\":1}}],[\"表达式的转换\",{\"1\":{\"102\":1}}],[\"表示栈顶\",{\"1\":{\"95\":1,\"104\":1,\"110\":1}}],[\"表示第i+1\",{\"1\":{\"79\":1}}],[\"表示第几行\",{\"1\":{\"79\":1}}],[\"表示最后一个节点\",{\"1\":{\"34\":1}}],[\"表示初始有几个小孩\",{\"1\":{\"26\":1,\"27\":1}}],[\"表示数几下\",{\"1\":{\"26\":1,\"27\":1}}],[\"表示从第几个小孩开始数数\",{\"1\":{\"26\":1,\"27\":1}}],[\"区域变量等数据存入堆栈中\",{\"1\":{\"102\":1}}],[\"只是除了储存下一个指令的地址外\",{\"1\":{\"102\":1}}],[\"只是可以向前\",{\"1\":{\"9\":1}}],[\"处理递归调用\",{\"1\":{\"102\":1}}],[\"以回到原来的程序中\",{\"1\":{\"102\":1}}],[\"会先将下个指令的地址存到堆栈中\",{\"1\":{\"102\":1}}],[\"会随着数据输出而改变\",{\"1\":{\"47\":1}}],[\"子程序的调用\",{\"1\":{\"102\":1}}],[\"发射从顶部开始弹出\",{\"1\":{\"101\":1}}],[\"发现链表的各个节点不一定是连续存储\",{\"1\":{\"30\":1}}],[\"可理解为一个弹夹从顶部压入子弹到底部\",{\"1\":{\"101\":1}}],[\"可以看出来前缀\",{\"1\":{\"96\":1}}],[\"可以使用稀疏数组来保存该数组\",{\"1\":{\"84\":1}}],[\"可以用数组或是链表来实现\",{\"1\":{\"46\":1}}],[\"称为栈底\",{\"1\":{\"101\":1}}],[\"称为栈顶\",{\"1\":{\"101\":1}}],[\"另一端为固定的一端\",{\"1\":{\"101\":1}}],[\"允许插入和删除的一端\",{\"1\":{\"101\":1}}],[\"丢弃左括号\",{\"1\":{\"98\":1}}],[\"转换成\",{\"1\":{\"98\":2}}],[\"转后缀表达式\",{\"1\":{\"96\":1}}],[\"举例\",{\"1\":{\"97\":1}}],[\"否则\",{\"1\":{\"97\":2}}],[\"否则无法存入数据\",{\"1\":{\"47\":1}}],[\"或栈顶运算符为左括号\",{\"1\":{\"97\":1}}],[\"或者为同一个值的数组时\",{\"1\":{\"84\":1}}],[\"比较其与s1栈顶运算符的优先级\",{\"1\":{\"97\":1}}],[\"比如快排\",{\"1\":{\"71\":1}}],[\"比如刚开始last=5\",{\"1\":{\"26\":1,\"27\":1}}],[\"比如\",{\"1\":{\"9\":1,\"89\":1,\"90\":1,\"91\":1}}],[\"具体步骤如下\",{\"1\":{\"97\":1}}],[\"人熟悉\",{\"1\":{\"96\":1}}],[\"弹出栈顶元素压入s2\",{\"1\":{\"98\":1}}],[\"弹出栈顶和次栈顶数字\",{\"1\":{\"96\":1,\"98\":1}}],[\"弹出栈顶的两个数\",{\"1\":{\"92\":1,\"96\":1}}],[\"正则表达式表示是数字\",{\"1\":{\"96\":1,\"98\":1}}],[\"接下来是×运算符\",{\"1\":{\"96\":1,\"98\":1}}],[\"接下来是x运算符\",{\"1\":{\"92\":1,\"96\":1}}],[\"压入堆栈\",{\"1\":{\"96\":1,\"98\":1}}],[\"针对后缀表达式求值步骤如下\",{\"1\":{\"96\":1}}],[\"针对前缀表达式求值步骤如下\",{\"1\":{\"92\":1}}],[\"自顶向下遍历\",{\"1\":{\"95\":1,\"109\":1,\"110\":1,\"117\":1,\"118\":1}}],[\"自己也的报数一次\",{\"1\":{\"26\":1,\"27\":1}}],[\"取出数据\",{\"1\":{\"95\":1,\"108\":1,\"110\":1,\"116\":1,\"118\":1}}],[\"取模\",{\"1\":{\"56\":1}}],[\"拼接数字\",{\"1\":{\"95\":1}}],[\"多位数需要向后看遇到符号停止\",{\"1\":{\"95\":1}}],[\"多位数字需要拼接之后再入\",{\"1\":{\"93\":1}}],[\"再将head的下一个指向node\",{\"1\":{\"115\":1}}],[\"再将7\",{\"1\":{\"96\":1,\"98\":1}}],[\"再将7入栈\",{\"1\":{\"92\":1,\"96\":1}}],[\"再压入一个数据\",{\"1\":{\"107\":1}}],[\"再执行上述流程\",{\"1\":{\"98\":1}}],[\"再次转到4\",{\"1\":{\"97\":1}}],[\"再从符号栈中\",{\"1\":{\"95\":1}}],[\"扫描得到的char\",{\"1\":{\"95\":1}}],[\"扫描索引\",{\"1\":{\"95\":1}}],[\"操作符栈\",{\"1\":{\"95\":1}}],[\"仍需要获得00进行拼接成100\",{\"1\":{\"95\":1}}],[\"返回栈顶的值但不出栈\",{\"1\":{\"94\":1,\"95\":1}}],[\"假定只有+\",{\"1\":{\"94\":1,\"95\":1}}],[\"假设可以走通\",{\"1\":{\"76\":1,\"77\":1}}],[\"假设从\",{\"1\":{\"72\":1}}],[\"假设countnum=2\",{\"1\":{\"26\":1,\"27\":1}}],[\"与求值\",{\"1\":{\"102\":1}}],[\"与前缀不同\",{\"1\":{\"96\":1}}],[\"与中缀相同\",{\"1\":{\"96\":1}}],[\"与pop不同\",{\"1\":{\"94\":1}}],[\"与单链表不同的是\",{\"1\":{\"14\":2,\"18\":1}}],[\"进行加减乘除计算\",{\"1\":{\"94\":1}}],[\"进行运算\",{\"1\":{\"93\":1,\"95\":2}}],[\"定义node节点\",{\"0\":{\"112\":1}}],[\"定义运算优先级\",{\"1\":{\"94\":1,\"95\":1}}],[\"定义几个工具方法\",{\"0\":{\"94\":1}}],[\"定义一共多少皇后\",{\"1\":{\"80\":1}}],[\"这样top始终指向顶部数据\",{\"1\":{\"107\":1}}],[\"这一点与前缀表达式求值相反\",{\"1\":{\"93\":1}}],[\"这个在做判断队列满的时候需要注意\",{\"1\":{\"59\":1}}],[\"注意这里35\",{\"1\":{\"96\":1}}],[\"注意这里是栈顶元素\",{\"1\":{\"92\":1}}],[\"注意运算时是次顶元素\",{\"1\":{\"93\":1}}],[\"来遍历我们的表达式\",{\"1\":{\"93\":1}}],[\"索引\",{\"1\":{\"93\":1}}],[\"值\",{\"1\":{\"93\":1}}],[\"通过一个index\",{\"1\":{\"93\":1}}],[\"通过取模的方式来实现即可\",{\"1\":{\"58\":1}}],[\"由此得出最终结果\",{\"1\":{\"92\":1,\"96\":2,\"98\":1}}],[\"由此产生一个出队编号的序列\",{\"1\":{\"21\":1}}],[\"运算符栈s1和储存中间结果的栈s2\",{\"1\":{\"97\":1}}],[\"运算符则pop两个数字用当前运算符进行计算\",{\"1\":{\"96\":1}}],[\"运算符\",{\"1\":{\"92\":1,\"95\":1,\"96\":2,\"98\":1}}],[\"得7\",{\"1\":{\"92\":1,\"96\":2,\"98\":1}}],[\"得到first和last指针表示环形队列队头和队尾\",{\"1\":{\"26\":1}}],[\"重复步骤2至5\",{\"1\":{\"97\":1}}],[\"重复上述过程直到表达式最右端\",{\"1\":{\"96\":1}}],[\"重复上述过程直到表达式最左端\",{\"1\":{\"92\":1}}],[\"重点是理解\",{\"1\":{\"14\":1}}],[\"并压入s2\",{\"1\":{\"97\":1}}],[\"并运行\",{\"1\":{\"93\":1,\"95\":2}}],[\"并将结果入栈\",{\"1\":{\"92\":1,\"96\":1}}],[\"并且创建尾节点last使得last\",{\"1\":{\"24\":1}}],[\"次顶元素\",{\"1\":{\"92\":2,\"96\":1}}],[\"遇到操作符停止\",{\"1\":{\"98\":1}}],[\"遇到括号时\",{\"1\":{\"97\":1}}],[\"遇到数时\",{\"1\":{\"97\":1}}],[\"遇到数字时\",{\"1\":{\"92\":1,\"96\":1}}],[\"遇到+运算符\",{\"1\":{\"92\":1,\"96\":2,\"98\":1}}],[\"遇到运算符时\",{\"1\":{\"92\":1,\"96\":1,\"97\":1}}],[\"它们就得对各个运算符进行优先级比较以及弹栈和入栈等操作\",{\"1\":{\"89\":1}}],[\"它的下一位又从\",{\"1\":{\"21\":1}}],[\"我们很容易就可以得到计算结果\",{\"1\":{\"89\":1}}],[\"缀\",{\"1\":{\"89\":1}}],[\"首先将node与1相连\",{\"1\":{\"115\":1}}],[\"首先第一步将\",{\"1\":{\"98\":1}}],[\"首先定义两个栈以及扫描索引\",{\"1\":{\"95\":1}}],[\"首先\",{\"1\":{\"89\":1}}],[\"总个数\",{\"1\":{\"85\":1}}],[\"总列数\",{\"1\":{\"85\":1}}],[\"总行数\",{\"1\":{\"85\":1}}],[\"总是指向尾节点\",{\"1\":{\"24\":1,\"27\":1}}],[\"总是找到\",{\"1\":{\"8\":1}}],[\"白子\",{\"1\":{\"85\":1}}],[\"黑子\",{\"1\":{\"85\":1}}],[\"模拟棋盘\",{\"1\":{\"85\":1}}],[\"原始二维数组\",{\"1\":{\"85\":1}}],[\"统计非0元素个数用于初始化稀疏数组\",{\"1\":{\"85\":1}}],[\"二叉树的遍历\",{\"1\":{\"102\":1}}],[\"二维数组转换为稀疏数组\",{\"1\":{\"85\":1}}],[\"二分查找\",{\"1\":{\"71\":1}}],[\"代表数组数据个数\",{\"1\":{\"84\":1}}],[\"代码实现\",{\"0\":{\"10\":1,\"22\":1,\"31\":1,\"48\":1,\"60\":1,\"73\":1,\"85\":1,\"98\":1}}],[\"x+3456\",{\"1\":{\"92\":1}}],[\"x5\",{\"1\":{\"92\":1,\"96\":1,\"98\":1}}],[\"x\",{\"1\":{\"84\":1,\"96\":1,\"98\":1}}],[\"把具有不同值的元素的行列及值记录在一个小规模的数组中\",{\"1\":{\"84\":1}}],[\"记录数组一共有几行几列\",{\"1\":{\"84\":1}}],[\"基本介绍\",{\"0\":{\"84\":1}}],[\"棋盘\",{\"1\":{\"83\":1}}],[\"有多少个不同的值\",{\"1\":{\"84\":1}}],[\"有存盘退出和续上盘的功能\",{\"1\":{\"83\":1}}],[\"有效数据个数\",{\"0\":{\"66\":1}}],[\"编写的五子棋程序中\",{\"1\":{\"83\":1}}],[\"编号\",{\"1\":{\"23\":1,\"25\":1,\"27\":2}}],[\"需求\",{\"0\":{\"83\":1}}],[\"需要先取出数据再将栈顶top指针向下移动\",{\"1\":{\"108\":1}}],[\"需要定一个策略\",{\"1\":{\"76\":1,\"77\":1}}],[\"需要靠辅助节点\",{\"1\":{\"8\":1}}],[\"种解法\",{\"1\":{\"80\":1}}],[\"共\",{\"1\":{\"80\":1}}],[\"检测皇后和已摆放皇后冲突\",{\"1\":{\"80\":1}}],[\"算法实现\",{\"0\":{\"80\":1}}],[\"算是找到了一个正确解\",{\"1\":{\"79\":1}}],[\"列表的表达式计算如下\",{\"1\":{\"96\":1}}],[\"列\",{\"1\":{\"79\":1}}],[\"放n+1个\",{\"1\":{\"80\":1}}],[\"放置第n个皇后\",{\"1\":{\"80\":1}}],[\"放在第i+1行的第\",{\"1\":{\"79\":1}}],[\"放到第一列的所有正确解\",{\"1\":{\"79\":1}}],[\"value\",{\"1\":{\"112\":4,\"116\":1,\"117\":1,\"118\":6}}],[\"valueof\",{\"1\":{\"98\":1}}],[\"val+1\",{\"1\":{\"79\":1}}],[\"val\",{\"1\":{\"79\":2,\"94\":5,\"95\":5}}],[\"void\",{\"1\":{\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"17\":1,\"18\":6,\"24\":1,\"25\":1,\"26\":1,\"27\":4,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"41\":1,\"42\":1,\"43\":8,\"52\":1,\"55\":3,\"64\":1,\"67\":3,\"75\":1,\"77\":2,\"80\":3,\"85\":2,\"95\":3,\"96\":1,\"98\":2,\"107\":1,\"109\":1,\"110\":3,\"115\":1,\"117\":1,\"118\":3}}],[\"对于一个处理成\",{\"1\":{\"96\":1}}],[\"对于中缀表达式弹出栈顶的两个数字\",{\"1\":{\"94\":1}}],[\"对于思路不必理解记住流程即可\",{\"1\":{\"93\":1}}],[\"对于复杂点的表达式\",{\"1\":{\"90\":1,\"91\":1}}],[\"对应的前缀表达式就是34+5x6\",{\"1\":{\"96\":1}}],[\"对应的前缀表达式就是\",{\"1\":{\"92\":1}}],[\"对应\",{\"1\":{\"79\":1}}],[\"对前面的数组模拟队列的优化\",{\"1\":{\"58\":1}}],[\"用于拼接多位数\",{\"1\":{\"95\":1}}],[\"用于判断优先级\",{\"1\":{\"94\":1}}],[\"用于构建环形链表\",{\"1\":{\"24\":1,\"27\":1}}],[\"用运算符对它们做相应的计算\",{\"1\":{\"92\":1,\"96\":1}}],[\"用一个一维数组即可解决问题\",{\"1\":{\"79\":1}}],[\"理论上应该创建一个二维数组来表示棋盘\",{\"1\":{\"79\":1}}],[\"全部得到\",{\"1\":{\"79\":1}}],[\"就顺序的从\",{\"1\":{\"95\":2}}],[\"就顺序的从数栈和符号栈中pop出相应的数和符号\",{\"1\":{\"93\":1}}],[\"就需要从数栈中\",{\"1\":{\"95\":2}}],[\"就需要从数栈中pop出两个数\",{\"1\":{\"93\":1}}],[\"就是表达式的结果\",{\"1\":{\"93\":1}}],[\"就是迷宫问题\",{\"1\":{\"72\":1}}],[\"就进行比较\",{\"1\":{\"93\":1,\"95\":1}}],[\"就直接入符号栈\",{\"1\":{\"93\":1}}],[\"就直接入栈\",{\"1\":{\"93\":1}}],[\"就直接入数栈\",{\"1\":{\"93\":1}}],[\"就分如下情况\",{\"1\":{\"93\":1}}],[\"就会开始回溯\",{\"1\":{\"79\":1}}],[\"个皇后\",{\"1\":{\"79\":1}}],[\"个皇后也能放在一个不冲突的位置\",{\"1\":{\"79\":1}}],[\"个人围坐一圈\",{\"1\":{\"21\":1}}],[\"还是第一列\",{\"1\":{\"79\":1}}],[\"继续第三个皇后\",{\"1\":{\"79\":1}}],[\"继续放在第二列\",{\"1\":{\"79\":1}}],[\"依次弹出s2中的元素并输出\",{\"1\":{\"97\":1}}],[\"依次放皇后并判断是否冲突\",{\"1\":{\"80\":1}}],[\"依次把所有列都放完\",{\"1\":{\"79\":1}}],[\"依次类推\",{\"1\":{\"21\":1}}],[\"第一列记录行\",{\"1\":{\"85\":1}}],[\"第一行为数据在二维数组中的\",{\"1\":{\"85\":1}}],[\"第一行第三列代表原始数组数据个数\",{\"1\":{\"84\":1}}],[\"第一行第二列代表原始数组总列数\",{\"1\":{\"84\":1}}],[\"第一行第一列代表原始数组总行数\",{\"1\":{\"84\":1}}],[\"第一个字符是1\",{\"1\":{\"95\":1}}],[\"第一个皇后先放第一行第一列\",{\"1\":{\"79\":1}}],[\"第一个节点\",{\"1\":{\"24\":2,\"27\":2}}],[\"第二行开始遍历\",{\"1\":{\"85\":1}}],[\"第二列记录列\",{\"1\":{\"85\":1}}],[\"第二列\",{\"1\":{\"79\":1}}],[\"第二个皇后放在第二行第一列\",{\"1\":{\"79\":1}}],[\"第三列记录值\",{\"1\":{\"85\":1}}],[\"第三列\",{\"1\":{\"79\":1}}],[\"思路分析\",{\"0\":{\"79\":1}}],[\"问有多少种摆法\",{\"1\":{\"78\":1}}],[\"问题及解决方案\",{\"0\":{\"56\":1}}],[\"问题为\",{\"1\":{\"21\":1}}],[\"问题\",{\"1\":{\"21\":1}}],[\"同一斜线\",{\"1\":{\"80\":1}}],[\"同一列\",{\"1\":{\"80\":1}}],[\"同一列或同一斜线上\",{\"1\":{\"78\":1}}],[\"同时count\",{\"1\":{\"116\":1}}],[\"同时计数器+1\",{\"1\":{\"115\":1}}],[\"同时需要设置栈大小maxsize\",{\"1\":{\"113\":1}}],[\"同时设置栈顶指针top初始化为\",{\"1\":{\"104\":1}}],[\"同时再从符号栈中\",{\"1\":{\"95\":1}}],[\"同时可以让代码变得简洁\",{\"1\":{\"70\":1}}],[\"同时将这一对括号丢弃\",{\"1\":{\"98\":1}}],[\"同时将last的next指向first\",{\"1\":{\"21\":1}}],[\"同时将first指向下一个位置\",{\"1\":{\"21\":1}}],[\"同时将待删除节点的下一个节点的pre指向待删除结点的上一个节点\",{\"1\":{\"14\":1}}],[\"任意两个皇后都不能处于同一行\",{\"1\":{\"78\":1}}],[\"格的国际象棋上摆放八个皇后\",{\"1\":{\"78\":1}}],[\"在跳往子程序前\",{\"1\":{\"102\":1}}],[\"在这里使用数组存储数据\",{\"1\":{\"104\":1}}],[\"在这里不用两个栈\",{\"1\":{\"98\":1}}],[\"在这个位置重新报数\",{\"1\":{\"21\":1}}],[\"在进行减法和除法时是次栈\",{\"1\":{\"94\":1}}],[\"在从符号栈中pop出一个符号\",{\"1\":{\"93\":1}}],[\"在栈回退到上一个栈时\",{\"1\":{\"79\":1}}],[\"在\",{\"1\":{\"78\":1}}],[\"年提出\",{\"1\":{\"78\":1}}],[\"贝瑟尔于1848\",{\"1\":{\"78\":1}}],[\"该问题是国际西洋棋棋手马克斯\",{\"1\":{\"78\":1}}],[\"能否走出迷宫\",{\"1\":{\"77\":1}}],[\"能到右下角则能找到即\",{\"1\":{\"76\":1,\"77\":1}}],[\"能到达右下角map\",{\"1\":{\"76\":1,\"77\":1}}],[\"置为3\",{\"1\":{\"76\":1,\"77\":1}}],[\"置为2\",{\"1\":{\"76\":1,\"77\":1}}],[\"说明该点走不通\",{\"1\":{\"76\":1,\"77\":1}}],[\"说明只剩下最后一个节点\",{\"1\":{\"26\":1,\"27\":1}}],[\"向左走\",{\"1\":{\"76\":1,\"77\":1}}],[\"向上走\",{\"1\":{\"76\":1,\"77\":1}}],[\"向右走\",{\"1\":{\"76\":1,\"77\":1}}],[\"向下走\",{\"1\":{\"76\":1,\"77\":1}}],[\"按策略走\",{\"1\":{\"76\":1,\"77\":1}}],[\"按照年纪从小到大插入节点\",{\"1\":{\"17\":1,\"18\":1,\"43\":1}}],[\"按照age从小到大插入节点\",{\"1\":{\"35\":1}}],[\"按照age\",{\"1\":{\"14\":1,\"18\":1,\"36\":1,\"43\":1}}],[\"从左至右扫描中缀表达式\",{\"1\":{\"97\":1}}],[\"从左至右扫描\",{\"1\":{\"96\":2,\"98\":1}}],[\"从左至右扫描表达式\",{\"1\":{\"96\":1}}],[\"从右至左扫描\",{\"1\":{\"92\":1}}],[\"从右至左扫描表达式\",{\"1\":{\"92\":1}}],[\"从而缩小程序的规模\",{\"1\":{\"84\":1}}],[\"从哪里开始找\",{\"1\":{\"76\":2,\"77\":2}}],[\"从头遍历length\",{\"1\":{\"40\":2}}],[\"地图\",{\"1\":{\"76\":1,\"77\":1}}],[\"走不通就再回溯\",{\"1\":{\"76\":1,\"77\":1}}],[\"走迷宫时\",{\"1\":{\"76\":1,\"77\":1}}],[\"左括号直接入s1\",{\"1\":{\"98\":1}}],[\"左\",{\"1\":{\"76\":2,\"77\":2}}],[\"左右置为1\",{\"1\":{\"74\":1,\"77\":1}}],[\"右括号\",{\"1\":{\"98\":1}}],[\"右\",{\"1\":{\"76\":2,\"77\":2}}],[\"为变化的一端\",{\"1\":{\"101\":1}}],[\"为次顶元素\",{\"1\":{\"96\":1,\"98\":1}}],[\"为栈顶元素\",{\"1\":{\"96\":1,\"98\":1}}],[\"为2表示通路可以走\",{\"1\":{\"76\":1,\"77\":1}}],[\"为1表示墙\",{\"1\":{\"76\":1,\"77\":1}}],[\"打印地图\",{\"0\":{\"75\":1},\"1\":{\"75\":1,\"77\":1}}],[\"设置挡板\",{\"1\":{\"77\":1}}],[\"设置挡板墙\",{\"1\":{\"74\":1}}],[\"设编号为\",{\"1\":{\"21\":1}}],[\"上\",{\"1\":{\"76\":2,\"77\":2}}],[\"上下全部置为1\",{\"1\":{\"74\":1,\"77\":1}}],[\"上一个节点指向temp\",{\"1\":{\"17\":1}}],[\"也将参数\",{\"1\":{\"102\":1}}],[\"也将运算符压入s1\",{\"1\":{\"97\":1}}],[\"也称逆波兰式\",{\"1\":{\"91\":1}}],[\"也称波兰式\",{\"1\":{\"90\":1}}],[\"也是墙设置为1\",{\"1\":{\"74\":1}}],[\"也可以向后查找\",{\"1\":{\"9\":1}}],[\"四周模拟围墙全部设置为1\",{\"1\":{\"74\":1}}],[\"创建一个8x7的迷宫如上图所示\",{\"1\":{\"74\":1}}],[\"创建node节点\",{\"0\":{\"11\":1}}],[\"路径为2标识的\",{\"1\":{\"72\":1}}],[\"寻找一个路径到达出口即算完成\",{\"1\":{\"72\":1}}],[\"开始出发\",{\"1\":{\"72\":1}}],[\"开始报数\",{\"1\":{\"21\":2}}],[\"找出从起点出发到终点的有效可行路径\",{\"1\":{\"72\":1}}],[\"找到一个合适\",{\"1\":{\"79\":1}}],[\"找到就返回true没有找到就是false\",{\"1\":{\"76\":1,\"77\":1}}],[\"找到对应节点\",{\"1\":{\"37\":1}}],[\"找到要删除节点的前一个位置\",{\"1\":{\"36\":1}}],[\"找到要删除节点位置\",{\"1\":{\"14\":1,\"18\":1}}],[\"找到合适位置\",{\"1\":{\"35\":1}}],[\"找到位置\",{\"1\":{\"17\":1,\"18\":1,\"43\":2}}],[\"指运算符处于两操作数后面\",{\"1\":{\"91\":1}}],[\"指运算符处于两个操作数的前面\",{\"1\":{\"90\":1}}],[\"指运算符在两个操作数的位置\",{\"1\":{\"89\":1}}],[\"指明起点和终点\",{\"1\":{\"72\":1}}],[\"指向队列头的位置\",{\"1\":{\"61\":1,\"67\":1}}],[\"指向队列头的前一个位置\",{\"1\":{\"49\":1,\"55\":1}}],[\"指向队列第一个数据\",{\"1\":{\"61\":1,\"67\":1}}],[\"指向队列最后一个数据的后一个位置\",{\"1\":{\"61\":2,\"67\":2}}],[\"指向队列最后一个数据\",{\"1\":{\"49\":1,\"55\":1}}],[\"指向尾节点\",{\"1\":{\"26\":1,\"27\":1}}],[\"指向下一个节点\",{\"1\":{\"11\":1,\"18\":1,\"30\":1,\"32\":1,\"43\":1}}],[\"指向上一个节点\",{\"1\":{\"11\":1,\"18\":1}}],[\"给定一个迷宫\",{\"1\":{\"72\":1}}],[\"归并排序\",{\"1\":{\"71\":1}}],[\"各种算法中也会使用到递归\",{\"1\":{\"71\":1}}],[\"各种数学问题\",{\"1\":{\"71\":1}}],[\"球和篮子的问题\",{\"1\":{\"71\":1}}],[\"阶乘问题\",{\"1\":{\"71\":1}}],[\"汉诺塔\",{\"1\":{\"71\":1}}],[\"皇后问题\",{\"1\":{\"71\":1}}],[\"八个皇后已然放好\",{\"1\":{\"80\":1}}],[\"八\",{\"1\":{\"71\":1}}],[\"八皇后问题\",{\"0\":{\"78\":1},\"1\":{\"78\":1}}],[\"八皇后\",{\"0\":{\"69\":1}}],[\"实际解决\",{\"1\":{\"102\":1}}],[\"实际问题\",{\"0\":{\"71\":1}}],[\"实际内存存储结构\",{\"1\":{\"30\":1}}],[\"每次调用时传入不同的变量\",{\"1\":{\"70\":1}}],[\"每个node节点包括的data为age和name\",{\"1\":{\"32\":1}}],[\"每个node包括data和next\",{\"1\":{\"30\":1}}],[\"每个节点包含\",{\"1\":{\"30\":1}}],[\"简单的说\",{\"1\":{\"70\":1}}],[\"简略图\",{\"1\":{\"30\":1}}],[\"概念\",{\"0\":{\"70\":1}}],[\"迷宫求解\",{\"0\":{\"76\":1}}],[\"迷宫问题\",{\"0\":{\"72\":1},\"1\":{\"71\":1}}],[\"迷宫\",{\"0\":{\"69\":1}}],[\"留下一个空位\",{\"1\":{\"67\":1}}],[\"最先放入的元素最后删除\",{\"1\":{\"101\":1}}],[\"最先放入栈中元素在栈底\",{\"1\":{\"101\":1}}],[\"最多装3个数据\",{\"1\":{\"67\":1}}],[\"最后放入的元素最先删除\",{\"1\":{\"101\":1}}],[\"最后放入的元素在栈顶\",{\"1\":{\"101\":1}}],[\"最后留在stack中就是结果\",{\"1\":{\"96\":1,\"98\":1}}],[\"最后留在数栈的元素就是计算结果\",{\"1\":{\"95\":1}}],[\"最后在数栈只有一个数字\",{\"1\":{\"93\":1}}],[\"最后是\",{\"1\":{\"92\":1,\"96\":2,\"98\":1}}],[\"最后运算得出的值即为表达式的结果\",{\"1\":{\"92\":1,\"96\":1}}],[\"最后存留的编号\",{\"1\":{\"26\":1,\"27\":1}}],[\"最后的顺序是\",{\"1\":{\"21\":1}}],[\"最后一个节点next指向新节点\",{\"1\":{\"13\":1,\"18\":1}}],[\"最后一个节点\",{\"1\":{\"13\":1,\"18\":1,\"43\":1}}],[\"queue\",{\"0\":{\"122\":1},\"1\":{\"67\":11}}],[\"尾索引的下一个为头索引时表示队列满\",{\"1\":{\"59\":1}}],[\"尾指针rear指向最后一个数据\",{\"1\":{\"49\":1}}],[\"尾指针\",{\"1\":{\"49\":1,\"55\":1,\"61\":1,\"67\":1}}],[\"分割表达式字符串的每一个字符\",{\"1\":{\"95\":1}}],[\"分治算法等\",{\"1\":{\"71\":1}}],[\"分析说明\",{\"0\":{\"59\":1}}],[\"分别记录队列前后端的下标\",{\"1\":{\"47\":1}}],[\"分别指向上一个节点和下一个节点\",{\"1\":{\"11\":1}}],[\"充分利用数组\",{\"1\":{\"58\":1}}],[\"改进成一个环形的队列\",{\"1\":{\"56\":1}}],[\"目前数组使用一次就不能用\",{\"1\":{\"56\":1}}],[\"目的是将最后节点的next指向新的节点\",{\"1\":{\"34\":1}}],[\"不冲突\",{\"1\":{\"80\":1}}],[\"不取出\",{\"0\":{\"54\":1},\"1\":{\"54\":1,\"55\":1,\"67\":1}}],[\"不存数据\",{\"1\":{\"33\":1,\"43\":1}}],[\"不存在\",{\"1\":{\"14\":1,\"18\":1,\"43\":1}}],[\"显示所有数据\",{\"1\":{\"55\":1,\"67\":1}}],[\"显示队列头数据\",{\"0\":{\"54\":1},\"1\":{\"54\":1,\"55\":1,\"67\":1}}],[\"显示链表\",{\"1\":{\"43\":1}}],[\"row\",{\"1\":{\"85\":2}}],[\"raw\",{\"1\":{\"85\":1}}],[\"runtimeexception\",{\"1\":{\"53\":1,\"54\":1,\"55\":2,\"65\":1,\"67\":2,\"95\":2,\"108\":1,\"109\":1,\"110\":2,\"116\":1,\"117\":1,\"118\":2}}],[\"recursion\",{\"0\":{\"123\":1}}],[\"res\",{\"1\":{\"94\":6,\"95\":11,\"96\":6,\"98\":6}}],[\"rebuild\",{\"1\":{\"85\":1}}],[\"rebuildarray\",{\"1\":{\"85\":3}}],[\"rear不再指向队列尾部数据\",{\"1\":{\"59\":1}}],[\"rear指向最后一个数据后一个位置\",{\"1\":{\"59\":1}}],[\"rear++\",{\"1\":{\"52\":1,\"55\":1}}],[\"rear+1\",{\"1\":{\"47\":1}}],[\"rear\",{\"1\":{\"47\":6,\"49\":2,\"50\":2,\"51\":2,\"52\":1,\"55\":8,\"59\":5,\"61\":2,\"62\":2,\"63\":2,\"64\":3,\"66\":1,\"67\":10}}],[\"reverseprint\",{\"1\":{\"42\":1,\"43\":2}}],[\"reverse\",{\"1\":{\"41\":1,\"43\":2}}],[\"return\",{\"1\":{\"3\":2,\"4\":2,\"11\":1,\"14\":2,\"15\":1,\"16\":2,\"17\":1,\"18\":7,\"24\":1,\"25\":1,\"26\":1,\"27\":3,\"32\":1,\"35\":1,\"36\":1,\"37\":2,\"39\":2,\"40\":3,\"41\":1,\"42\":1,\"43\":13,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":6,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":7,\"74\":1,\"76\":8,\"77\":9,\"80\":3,\"94\":6,\"95\":10,\"98\":7,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"110\":4,\"114\":2,\"115\":1,\"116\":1,\"118\":4}}],[\"出栈pop\",{\"0\":{\"108\":1,\"116\":1}}],[\"出栈入栈\",{\"1\":{\"101\":1}}],[\"出栈\",{\"1\":{\"95\":1,\"101\":1,\"108\":1,\"110\":1,\"116\":1,\"118\":1}}],[\"出相应的数和符号\",{\"1\":{\"95\":2}}],[\"出一个符号\",{\"1\":{\"95\":2}}],[\"出两个数\",{\"1\":{\"95\":2}}],[\"出发点\",{\"1\":{\"76\":1,\"77\":1}}],[\"出队列\",{\"1\":{\"53\":1,\"55\":1,\"65\":1,\"67\":1}}],[\"出队\",{\"0\":{\"53\":1,\"65\":1},\"1\":{\"55\":1,\"67\":1}}],[\"出圈\",{\"1\":{\"26\":1,\"27\":1}}],[\"入数栈\",{\"1\":{\"93\":1,\"95\":2}}],[\"入队\",{\"0\":{\"52\":1}}],[\"入栈push\",{\"0\":{\"107\":1,\"115\":1}}],[\"入栈\",{\"1\":{\"42\":1,\"95\":1,\"96\":5,\"98\":5,\"101\":1,\"107\":1,\"110\":1,\"115\":1,\"118\":1}}],[\"队满\",{\"0\":{\"51\":1,\"63\":1},\"1\":{\"59\":1}}],[\"队空\",{\"0\":{\"50\":1,\"62\":1},\"1\":{\"59\":1}}],[\"队列有效数据个数\",{\"1\":{\"66\":1,\"67\":1}}],[\"队列中数据个数\",{\"1\":{\"59\":1}}],[\"队列\",{\"2\":{\"57\":1,\"68\":1}}],[\"队列首部数据\",{\"1\":{\"55\":1,\"67\":1}}],[\"队列为空\",{\"1\":{\"53\":1,\"54\":1,\"55\":3,\"65\":1,\"67\":3}}],[\"队列满不能再继续添加\",{\"1\":{\"52\":1,\"55\":1,\"64\":1,\"67\":1}}],[\"队列满\",{\"1\":{\"51\":1,\"55\":1,\"63\":1,\"67\":1}}],[\"队列空\",{\"1\":{\"50\":1,\"55\":1,\"59\":1,\"62\":1,\"67\":1}}],[\"队列存储\",{\"1\":{\"49\":1,\"55\":1,\"61\":1,\"67\":1}}],[\"队列本身是有序列表\",{\"1\":{\"47\":1}}],[\"队列是一个有序列表\",{\"1\":{\"46\":1}}],[\"队列介绍\",{\"0\":{\"46\":1}}],[\"规约\",{\"1\":{\"49\":2,\"55\":2,\"61\":2,\"67\":2}}],[\"头插发\",{\"1\":{\"115\":1}}],[\"头指针front指向队列头的前一个位置\",{\"1\":{\"49\":1}}],[\"头指针\",{\"1\":{\"49\":1,\"55\":1,\"61\":1,\"67\":1}}],[\"头节点\",{\"1\":{\"33\":1,\"43\":1,\"113\":1,\"118\":1}}],[\"所指的数组元素中\",{\"1\":{\"47\":1}}],[\"所以数字时需要判断直到遇到运算符停止\",{\"1\":{\"95\":1}}],[\"所以last\",{\"1\":{\"26\":1}}],[\"所以前面我们单链表删除时节点\",{\"1\":{\"8\":1}}],[\"小于队列的最大下标\",{\"1\":{\"47\":1}}],[\"小一\",{\"1\":{\"43\":1}}],[\"若优先级比栈顶运算符的高\",{\"1\":{\"97\":1}}],[\"若尾指针\",{\"1\":{\"47\":1}}],[\"若使用数组的结构来存储队列的数据\",{\"1\":{\"47\":1}}],[\"而删除元素刚好相反\",{\"1\":{\"101\":1}}],[\"而是用一个栈一个list处理\",{\"1\":{\"98\":1}}],[\"而是指向尾部数据下一个位置\",{\"1\":{\"59\":1}}],[\"而是指向头一个数据\",{\"1\":{\"59\":1}}],[\"而后缀是从左到右扫描符合习惯\",{\"1\":{\"96\":1}}],[\"而计算机也更擅长处理前缀和后缀\",{\"1\":{\"96\":1}}],[\"而\",{\"1\":{\"47\":1}}],[\"而双链表可以直接找到删除的节点自我删除\",{\"1\":{\"14\":2,\"18\":1}}],[\"而双向链表\",{\"1\":{\"8\":1}}],[\"而双向链表可以向前或者向后查找\",{\"1\":{\"8\":1}}],[\"及\",{\"1\":{\"47\":1}}],[\"输入是分别从前后端来处理\",{\"1\":{\"47\":1}}],[\"输入数据不正确\",{\"1\":{\"26\":1,\"27\":1}}],[\"叫到号才可以吃\",{\"1\":{\"46\":1}}],[\"晚来的继续排队\",{\"1\":{\"46\":1}}],[\"轮到你你先吃\",{\"1\":{\"46\":1}}],[\"示意图\",{\"1\":{\"46\":2,\"59\":2}}],[\"要先取出\",{\"1\":{\"46\":1}}],[\"遵循先入先出的原则\",{\"1\":{\"46\":1}}],[\"反转\",{\"1\":{\"43\":1}}],[\"倒数第二个\",{\"1\":{\"43\":1}}],[\"长度\",{\"1\":{\"43\":1}}],[\"大大大啊三\",{\"1\":{\"43\":1}}],[\"大二\",{\"1\":{\"43\":1}}],[\"中三\",{\"1\":{\"43\":1}}],[\"中缀表达式转后缀表达式\",{\"0\":{\"97\":1},\"1\":{\"98\":2,\"102\":1}}],[\"中缀表达式求值\",{\"0\":{\"93\":1}}],[\"中缀表达式其实就是我们常用的算术表达式\",{\"1\":{\"89\":1}}],[\"中缀表达式的这个\",{\"1\":{\"89\":1}}],[\"中缀表达式\",{\"0\":{\"89\":1}}],[\"中缀\",{\"0\":{\"87\":1,\"88\":1},\"1\":{\"1\":1}}],[\"节点全部正序入栈\",{\"1\":{\"42\":1}}],[\"后续会讲怎么转换\",{\"1\":{\"91\":1}}],[\"后续分析怎么转换\",{\"1\":{\"90\":1}}],[\"后面继续循环执行\",{\"1\":{\"79\":1}}],[\"后存入的要后取出\",{\"1\":{\"46\":1}}],[\"后移\",{\"1\":{\"42\":1,\"64\":1,\"65\":1,\"67\":2}}],[\"后缀表达式求值比中缀简单得多\",{\"1\":{\"96\":1}}],[\"后缀表达式求值\",{\"0\":{\"96\":1}}],[\"后缀表达式为\",{\"1\":{\"91\":2}}],[\"后缀表达式\",{\"0\":{\"87\":1,\"88\":1,\"91\":1},\"1\":{\"1\":1}}],[\"下面将介绍如何将中缀表达式\",{\"1\":{\"96\":1}}],[\"下面n行的第三列代表数据在原始数组的值\",{\"1\":{\"84\":1}}],[\"下面n行的第二列代表数据在原始数组第几列\",{\"1\":{\"84\":1}}],[\"下面n行的第一列代表数据在原始数组第几行\",{\"1\":{\"84\":1}}],[\"下面方法\",{\"1\":{\"42\":1}}],[\"下标\",{\"1\":{\"79\":1}}],[\"下\",{\"1\":{\"76\":2,\"77\":2}}],[\"下次一次从3开始报数\",{\"1\":{\"26\":1,\"27\":1}}],[\"先将栈顶指针向上移动一位\",{\"1\":{\"107\":1}}],[\"先入后出\",{\"1\":{\"101\":1}}],[\"先把当前的放到改行的第一列\",{\"1\":{\"80\":1}}],[\"先来先排\",{\"1\":{\"46\":1}}],[\"先存入队列的数据\",{\"1\":{\"46\":1}}],[\"先进后出\",{\"1\":{\"42\":1}}],[\"先reverse再遍历\",{\"1\":{\"42\":1}}],[\"先逆序再遍历打印\",{\"1\":{\"42\":1,\"43\":1}}],[\"先找到双向链表的最后这个节点\",{\"1\":{\"9\":1}}],[\"百度面试题\",{\"0\":{\"42\":1},\"1\":{\"43\":1}}],[\"逆序打印\",{\"0\":{\"42\":1},\"1\":{\"43\":1}}],[\"当栈满时top位于最顶部即maxsize\",{\"1\":{\"105\":1}}],[\"当str优先级小于等于s1栈顶的\",{\"1\":{\"98\":1}}],[\"当表达式扫描完毕\",{\"1\":{\"93\":1,\"95\":2}}],[\"当一个数组中大部分元素为０\",{\"1\":{\"84\":1}}],[\"当得到一个正确解时\",{\"1\":{\"79\":1}}],[\"当前点还没走过\",{\"1\":{\"76\":1,\"77\":1}}],[\"当前节点的下一个节点\",{\"1\":{\"41\":1,\"43\":1}}],[\"当map\",{\"1\":{\"76\":1,\"77\":1}}],[\"当队列空\",{\"1\":{\"47\":1}}],[\"当我们将数据存入队列时称为addqueue\",{\"1\":{\"47\":1}}],[\"当i==1时候\",{\"1\":{\"24\":1}}],[\"腾讯面试题\",{\"0\":{\"41\":1},\"1\":{\"43\":1}}],[\"变成3\",{\"0\":{\"41\":1},\"1\":{\"43\":1}}],[\"获取链表长度\",{\"1\":{\"40\":1}}],[\"获取链表有效节点个数\",{\"0\":{\"39\":1},\"1\":{\"43\":1}}],[\"获取倒数k个节点\",{\"0\":{\"40\":1},\"1\":{\"43\":1}}],[\"计算机熟悉\",{\"1\":{\"96\":1}}],[\"计算机学徒\",{\"1\":{\"0\":1}}],[\"计算结果\",{\"1\":{\"95\":1}}],[\"计算方法\",{\"1\":{\"94\":1,\"95\":1}}],[\"计算思路对于一个中缀表达式字符串36\",{\"1\":{\"93\":1}}],[\"计算出\",{\"1\":{\"96\":3,\"98\":3}}],[\"计算出35\",{\"1\":{\"92\":1,\"96\":1}}],[\"计算出3+4的值\",{\"1\":{\"92\":1,\"96\":1}}],[\"计算出7x5=35\",{\"1\":{\"92\":1,\"96\":1}}],[\"计数即n个数据n行\",{\"1\":{\"85\":1}}],[\"计数器\",{\"1\":{\"39\":1,\"113\":1,\"118\":1}}],[\"新头节点\",{\"1\":{\"41\":1}}],[\"新浪面试题\",{\"0\":{\"39\":1,\"40\":1},\"1\":{\"43\":2}}],[\"新节点的pre的指向最后一个节点\",{\"1\":{\"13\":1,\"18\":1}}],[\"去除头节点\",{\"0\":{\"39\":1},\"1\":{\"43\":1}}],[\"面试题\",{\"0\":{\"38\":1}}],[\"到达尾部\",{\"1\":{\"37\":1}}],[\"到达链表尾部\",{\"1\":{\"14\":1,\"18\":1,\"36\":1}}],[\"已经到达链表尾部\",{\"1\":{\"35\":1}}],[\"已经存在\",{\"1\":{\"17\":3,\"18\":3,\"35\":2,\"43\":3}}],[\"辅助接点\",{\"1\":{\"35\":1,\"36\":1}}],[\"辅助节点\",{\"1\":{\"34\":1,\"37\":1}}],[\"辅助指针\",{\"1\":{\"14\":1,\"18\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":3,\"41\":1,\"43\":1}}],[\"其实计算机对于前缀表达式和后缀表达式更容易理解\",{\"1\":{\"89\":1}}],[\"其中乘除优先级大于加减\",{\"1\":{\"94\":1}}],[\"其中\",{\"1\":{\"84\":1}}],[\"其中maxsize\",{\"1\":{\"47\":1}}],[\"其中head不存储信息\",{\"1\":{\"30\":1}}],[\"其余节点类似\",{\"1\":{\"24\":1}}],[\"详细图\",{\"1\":{\"30\":1}}],[\"逻辑结构示意图如下\",{\"1\":{\"30\":1}}],[\"带头结点\",{\"1\":{\"30\":1}}],[\"如1+2则1和2是单个数\",{\"1\":{\"95\":1}}],[\"如\",{\"1\":{\"90\":1,\"91\":1}}],[\"如下如图\",{\"1\":{\"72\":1}}],[\"如饭店排号系统\",{\"1\":{\"46\":1}}],[\"如果先移动再取出则取出的就不是栈顶数据而是次栈顶数据了\",{\"1\":{\"108\":1}}],[\"如果c是非数字加入arraylist\",{\"1\":{\"98\":1}}],[\"如果s1为空\",{\"1\":{\"97\":1}}],[\"如果为空则入栈\",{\"1\":{\"95\":1}}],[\"如果优先级大于则直接入符号栈\",{\"1\":{\"95\":2}}],[\"如果是右括号\",{\"1\":{\"97\":1}}],[\"如果是左括号\",{\"1\":{\"97\":1}}],[\"如果是操作符就进行比较\",{\"1\":{\"95\":1}}],[\"如果是数字则进行判断是否是多位数\",{\"1\":{\"95\":1}}],[\"如果当前的操作符的优先级小于或者等于栈顶的操作符\",{\"1\":{\"95\":2}}],[\"如果当前的操作符的优先级小于或者等于栈中的操作符\",{\"1\":{\"93\":1}}],[\"如果当前的操作符的优先级大于栈中的操作符\",{\"1\":{\"93\":1}}],[\"如果符号栈有操作符\",{\"1\":{\"93\":1,\"95\":1}}],[\"如果发现当前的符号栈为空\",{\"1\":{\"93\":1}}],[\"如果发现扫描到是一个符号\",{\"1\":{\"93\":1}}],[\"如果我们发现是一个数字\",{\"1\":{\"93\":1}}],[\"如果不\",{\"1\":{\"79\":1}}],[\"如果不等于0可能是1\",{\"1\":{\"76\":1,\"77\":1}}],[\"如果已经存在\",{\"1\":{\"35\":1}}],[\"如果已经存在则添加失败\",{\"1\":{\"17\":1,\"18\":1,\"43\":1}}],[\"如果2已经存在则添加失败\",{\"1\":{\"35\":1}}],[\"如图\",{\"1\":{\"30\":1}}],[\"存储数据\",{\"1\":{\"30\":1}}],[\"域\",{\"1\":{\"30\":2}}],[\"是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表\",{\"1\":{\"101\":1}}],[\"是回溯算法的典型案例\",{\"1\":{\"78\":1}}],[\"是一个古老而著名的问题\",{\"1\":{\"78\":1}}],[\"是该队列的最大容量\",{\"1\":{\"47\":1}}],[\"是链式存储\",{\"1\":{\"30\":1}}],[\"是待删除节点的前一个节点\",{\"1\":{\"8\":1}}],[\"没有棋子\",{\"1\":{\"85\":1}}],[\"没有达到复用的效果\",{\"1\":{\"56\":1}}],[\"没找到\",{\"1\":{\"36\":1}}],[\"没找到继续后移\",{\"1\":{\"35\":1,\"36\":1}}],[\"没找到最后一个节点就后移\",{\"1\":{\"13\":1,\"18\":1,\"43\":1}}],[\"没到最后一个节点就后移\",{\"1\":{\"34\":1}}],[\"没学过操作系统可以忽略\",{\"1\":{\"30\":2}}],[\"但使用的是一个栈s1一个list\",{\"1\":{\"98\":1}}],[\"但是对于计算机来说\",{\"1\":{\"89\":1}}],[\"但是实际上可以通过算法\",{\"1\":{\"79\":1}}],[\"但是它在内存中是存储如下\",{\"1\":{\"30\":1}}],[\"但始终保持最后一个节点的next为first节点\",{\"1\":{\"24\":1}}],[\"结果的逆序即为中缀表达式对应的后缀表达式\",{\"1\":{\"97\":1}}],[\"结果\",{\"1\":{\"27\":1,\"95\":1,\"96\":1,\"98\":1}}],[\"刚开始last=5\",{\"1\":{\"26\":1,\"27\":1}}],[\"那么前缀表达式就是\",{\"1\":{\"90\":1}}],[\"那么报两次\",{\"1\":{\"26\":1,\"27\":1}}],[\"那我们先将last和first移动startno\",{\"1\":{\"26\":1,\"27\":1}}],[\"移动countnum\",{\"1\":{\"26\":1,\"27\":1}}],[\"||\",{\"1\":{\"26\":2,\"27\":2,\"40\":1,\"41\":1,\"43\":2,\"72\":1,\"80\":1,\"94\":5,\"95\":6,\"98\":3}}],[\"此时将这一对括号丢弃\",{\"1\":{\"97\":1}}],[\"此时cur=1\",{\"1\":{\"41\":1}}],[\"此时last=1\",{\"1\":{\"26\":2,\"27\":2}}],[\"此时first=3\",{\"1\":{\"26\":1,\"27\":1}}],[\"此时first=2\",{\"1\":{\"26\":1,\"27\":1}}],[\"此时first和last都移动1位\",{\"1\":{\"26\":1}}],[\"此时temp为最后一个节点\",{\"1\":{\"34\":1}}],[\"此时temp为要删除节点\",{\"1\":{\"14\":1,\"18\":1}}],[\"此时temp=1\",{\"1\":{\"17\":1,\"18\":1}}],[\"报数1\",{\"1\":{\"26\":1,\"27\":1}}],[\"报数时\",{\"1\":{\"26\":1,\"27\":1}}],[\"报数前先移动startno\",{\"1\":{\"26\":1,\"27\":1}}],[\"报数出队\",{\"0\":{\"26\":1}}],[\"报m则移动m\",{\"1\":{\"26\":1}}],[\"则拼接再入栈\",{\"1\":{\"98\":1}}],[\"则依次弹出s1栈顶的运算符\",{\"1\":{\"97\":1}}],[\"则直接压入s1\",{\"1\":{\"97\":1}}],[\"则直接将此运算符入栈\",{\"1\":{\"97\":1}}],[\"则通路找到\",{\"1\":{\"76\":1,\"77\":1}}],[\"则将数据存入\",{\"1\":{\"47\":1}}],[\"则是随着数据输入而改变\",{\"1\":{\"47\":1}}],[\"则队列数组的声明如上图\",{\"1\":{\"47\":1}}],[\"则1\",{\"1\":{\"36\":1}}],[\"则第一个出圈是2\",{\"1\":{\"26\":1,\"27\":1}}],[\"则第一个出队的将是2号\",{\"1\":{\"26\":1}}],[\"则first=3\",{\"1\":{\"26\":1}}],[\"则first=1\",{\"1\":{\"26\":1}}],[\"则从3号重新报数\",{\"1\":{\"26\":1}}],[\"则可以自我删除\",{\"1\":{\"8\":1}}],[\"和子程序的调用类似\",{\"1\":{\"102\":1}}],[\"和\",{\"1\":{\"74\":1,\"92\":1,\"96\":4,\"98\":3,\"101\":1}}],[\"和上面解题思路一样\",{\"1\":{\"26\":1}}],[\"和单向链表一样\",{\"1\":{\"16\":1,\"18\":1}}],[\"和单链表没区别\",{\"1\":{\"16\":1}}],[\"和单链表遍历没区别\",{\"1\":{\"15\":1}}],[\"构成环\",{\"1\":{\"24\":1,\"27\":1}}],[\"构建环形链表\",{\"1\":{\"24\":1,\"27\":1}}],[\"根据栈的定义可知\",{\"1\":{\"101\":1}}],[\"根据第一行数据初始化二维数组\",{\"1\":{\"85\":1}}],[\"根据非0元素个数构造n行填充数据\",{\"1\":{\"85\":1}}],[\"根据实际的需求来确定\",{\"1\":{\"30\":1}}],[\"根据编号创建小孩节点\",{\"1\":{\"24\":1,\"27\":1}}],[\"根据age大小插入节点\",{\"0\":{\"35\":1}}],[\"根据age插入节点\",{\"0\":{\"17\":1}}],[\"根据age修改节点\",{\"0\":{\"16\":1,\"37\":1},\"1\":{\"16\":1,\"18\":1,\"37\":1,\"43\":1}}],[\"根据age删除节点\",{\"0\":{\"14\":1,\"36\":1}}],[\"然后将计算结果入栈\",{\"1\":{\"96\":1}}],[\"然后将拼接的数字直接入数栈\",{\"1\":{\"95\":1}}],[\"然后将当前的操作符入符号栈\",{\"1\":{\"93\":1,\"95\":2}}],[\"然后回头继续第一个皇后放第二列\",{\"1\":{\"79\":1}}],[\"然后判断是否\",{\"1\":{\"79\":1}}],[\"然后next用于指向下一个节点\",{\"1\":{\"32\":1}}],[\"然后addboy用于构建环形队列\",{\"1\":{\"24\":1}}],[\"然后出队删除first所在位置\",{\"1\":{\"21\":1}}],[\"初始化链表\",{\"0\":{\"113\":1}}],[\"初始化两个栈\",{\"1\":{\"97\":1}}],[\"初始化稀疏数组\",{\"1\":{\"85\":1}}],[\"初始化地图\",{\"0\":{\"74\":1},\"1\":{\"74\":1,\"77\":1}}],[\"初始化为0\",{\"1\":{\"59\":2}}],[\"初始化队列\",{\"1\":{\"49\":1,\"55\":1}}],[\"初始化\",{\"0\":{\"49\":1,\"61\":1,\"104\":1},\"1\":{\"95\":1,\"104\":1,\"110\":1}}],[\"初始化第一个节点为first为空\",{\"1\":{\"24\":1}}],[\"初始化环形链表\",{\"0\":{\"24\":1}}],[\"初始化节点\",{\"0\":{\"23\":1}}],[\"初始化头节点\",{\"0\":{\"12\":1},\"1\":{\"12\":1,\"18\":1}}],[\"使其不能互相攻击\",{\"1\":{\"78\":1}}],[\"使得始终维持一个环形队列\",{\"1\":{\"21\":1}}],[\"使用带头节点链表因此需要初始化head\",{\"1\":{\"113\":1}}],[\"使用两个栈\",{\"1\":{\"93\":1}}],[\"使用两个指针first和last分别表示第一个和最后一个\",{\"1\":{\"21\":1}}],[\"使用递归回溯给小球找路\",{\"1\":{\"76\":1,\"77\":1}}],[\"使用二维数组模拟迷宫\",{\"1\":{\"74\":1,\"77\":1}}],[\"使用数组模拟队列示意图\",{\"1\":{\"46\":1}}],[\"使用栈\",{\"1\":{\"42\":1,\"43\":1}}],[\"使用环形链表来模拟\",{\"1\":{\"21\":1}}],[\"即head\",{\"1\":{\"115\":1}}],[\"即node\",{\"1\":{\"115\":1}}],[\"即对于新节点node\",{\"1\":{\"115\":1}}],[\"即指针不移动\",{\"1\":{\"94\":1}}],[\"即29\",{\"1\":{\"92\":1,\"96\":1}}],[\"即记录为2\",{\"1\":{\"84\":1}}],[\"即记录为1\",{\"1\":{\"84\":1}}],[\"即为n\",{\"1\":{\"84\":1}}],[\"即可以用\",{\"1\":{\"84\":1}}],[\"即斜率为1\",{\"1\":{\"80\":1}}],[\"即第几个皇后\",{\"1\":{\"79\":1}}],[\"即第一个报数的人和最后一个报数的人\",{\"1\":{\"26\":1}}],[\"即将第一个皇后\",{\"1\":{\"79\":1}}],[\"即队列满\",{\"1\":{\"47\":1}}],[\"即\",{\"1\":{\"46\":1,\"78\":1,\"96\":1,\"98\":1}}],[\"即上面获取有效节点个数\",{\"1\":{\"40\":1}}],[\"即一个完整的链表通常包括\",{\"1\":{\"30\":1}}],[\"即报数为2的出列\",{\"1\":{\"21\":1}}],[\"即从1号开始报数\",{\"1\":{\"21\":1}}],[\"即有五个人\",{\"1\":{\"21\":1}}],[\"即temp\",{\"1\":{\"14\":2,\"17\":1}}],[\"例如head\",{\"1\":{\"115\":1}}],[\"例如\",{\"1\":{\"92\":1,\"96\":1}}],[\"例如1则记录为1\",{\"1\":{\"84\":1}}],[\"例如1位于\",{\"1\":{\"84\":2}}],[\"例如11\",{\"1\":{\"84\":2}}],[\"例如原始数组只有两个数据1和2\",{\"1\":{\"84\":1}}],[\"例如删除2\",{\"1\":{\"36\":1}}],[\"例如2应该插入1\",{\"1\":{\"35\":1,\"43\":1}}],[\"例如2应该插入1=3之间变成1=2=3\",{\"1\":{\"17\":1,\"18\":1}}],[\"例如m=2\",{\"1\":{\"26\":1}}],[\"例如从1号开始报数\",{\"1\":{\"26\":1}}],[\"例子\",{\"1\":{\"21\":1}}],[\"直到子程序执行完后再将地址取出\",{\"1\":{\"102\":1}}],[\"直到表达式的最右边\",{\"1\":{\"97\":1}}],[\"直到遇到左括号为止\",{\"1\":{\"97\":1,\"98\":1}}],[\"直到第\",{\"1\":{\"79\":1}}],[\"直到所有人出列为止\",{\"1\":{\"21\":1}}],[\"直接找到要删除的这个节点\",{\"1\":{\"9\":1}}],[\"migong\",{\"1\":{\"77\":1}}],[\"m=2\",{\"1\":{\"21\":1}}],[\"m\",{\"1\":{\"21\":2,\"76\":1,\"77\":1}}],[\"matches\",{\"1\":{\"96\":1,\"98\":2}}],[\"math\",{\"1\":{\"80\":4}}],[\"max\",{\"1\":{\"80\":4}}],[\"maxsize\",{\"1\":{\"47\":2,\"49\":5,\"51\":2,\"55\":7,\"59\":4,\"61\":5,\"63\":2,\"64\":1,\"65\":1,\"66\":2,\"67\":12,\"95\":6,\"104\":5,\"105\":1,\"110\":6,\"113\":4,\"114\":1,\"118\":5}}],[\"maze\",{\"1\":{\"72\":1}}],[\"main\",{\"1\":{\"18\":1,\"27\":1,\"43\":1,\"55\":1,\"67\":1,\"77\":1,\"80\":1,\"85\":1,\"95\":1,\"98\":1,\"110\":1,\"118\":1}}],[\"map\",{\"1\":{\"4\":4,\"74\":8,\"75\":2,\"76\":10,\"77\":24}}],[\"map<integer\",{\"1\":{\"4\":1}}],[\"keepnum\",{\"1\":{\"95\":5}}],[\"k个数据即为倒数第k个\",{\"1\":{\"40\":1}}],[\"k个数据\",{\"1\":{\"40\":1}}],[\"k=1\",{\"1\":{\"21\":1}}],[\"k\",{\"1\":{\"21\":1,\"40\":4,\"43\":5}}],[\"约定\",{\"1\":{\"76\":1,\"77\":1}}],[\"约定编号为\",{\"1\":{\"21\":1}}],[\"约瑟夫环\",{\"1\":{\"21\":1}}],[\"约瑟夫\",{\"1\":{\"21\":1}}],[\"约瑟夫问题解题思路\",{\"1\":{\"21\":1}}],[\"约瑟夫问题\",{\"0\":{\"20\":1}}],[\"的概念\",{\"1\":{\"101\":1}}],[\"的有序列表\",{\"1\":{\"101\":1}}],[\"的值\",{\"1\":{\"96\":2,\"98\":2}}],[\"的步骤\",{\"1\":{\"79\":1}}],[\"的处理需要有以下几个步骤\",{\"1\":{\"47\":1}}],[\"的那个人又出列\",{\"1\":{\"21\":1}}],[\"的那个人出列\",{\"1\":{\"21\":1}}],[\"的人从1\",{\"1\":{\"21\":1}}],[\"的\",{\"1\":{\"21\":1}}],[\"链表模拟栈\",{\"0\":{\"111\":1}}],[\"链表尾部\",{\"1\":{\"43\":2}}],[\"链表分带头节点的链表和没有头节点的链表\",{\"1\":{\"30\":1}}],[\"链表是以节点的方式来存储\",{\"1\":{\"30\":1}}],[\"链表是有序的列表\",{\"1\":{\"30\":1}}],[\"链表介绍\",{\"0\":{\"30\":1}}],[\"链表为空\",{\"1\":{\"25\":1,\"27\":1,\"37\":1,\"43\":1}}],[\"链表\",{\"2\":{\"19\":1,\"28\":1,\"44\":1}}],[\"yi\",{\"1\":{\"18\":3}}],[\"linkedliststack\",{\"1\":{\"113\":2,\"118\":4}}],[\"little\",{\"1\":{\"43\":1}}],[\"liststack\",{\"1\":{\"118\":8}}],[\"list可以直接遍历方便一些\",{\"1\":{\"98\":1}}],[\"list<string>\",{\"1\":{\"96\":1,\"98\":7}}],[\"list\",{\"0\":{\"121\":1},\"1\":{\"18\":9,\"27\":4,\"43\":16,\"95\":1,\"109\":1,\"110\":2,\"117\":1,\"118\":2}}],[\"lsat=1必须指向3才可以位置环形队列\",{\"1\":{\"26\":1}}],[\"last=1\",{\"1\":{\"26\":1}}],[\"last=5\",{\"1\":{\"26\":1}}],[\"last\",{\"1\":{\"24\":4,\"26\":11,\"27\":15,\"101\":1}}],[\"last移动到first的上一个位置也就是环形的队尾\",{\"1\":{\"21\":1}}],[\"length++\",{\"1\":{\"39\":1,\"43\":1}}],[\"length\",{\"1\":{\"3\":2,\"4\":3,\"39\":3,\"40\":3,\"43\":6,\"85\":5,\"95\":2,\"98\":2}}],[\"leetcode\",{\"0\":{\"2\":1,\"6\":1},\"1\":{\"2\":1,\"6\":1},\"2\":{\"5\":1}}],[\"完整代码\",{\"0\":{\"18\":1,\"27\":1,\"43\":1,\"55\":1,\"67\":1,\"77\":1,\"95\":1,\"110\":1,\"118\":1}}],[\"插入失败\",{\"1\":{\"17\":1,\"18\":1,\"35\":1,\"43\":1}}],[\"插入时首先将待插入节点node的上一个位置\",{\"1\":{\"17\":1}}],[\"equals\",{\"1\":{\"96\":4,\"98\":11}}],[\"explist\",{\"1\":{\"98\":2}}],[\"exp\",{\"1\":{\"96\":2,\"98\":4}}],[\"expression\",{\"1\":{\"95\":6}}],[\"eightqueue\",{\"1\":{\"80\":6}}],[\"er\",{\"1\":{\"18\":3}}],[\"else\",{\"1\":{\"17\":1,\"18\":1,\"24\":1,\"27\":1,\"35\":1,\"43\":1,\"76\":6,\"77\":6,\"94\":2,\"95\":5,\"96\":4,\"98\":10}}],[\"editbyage\",{\"1\":{\"16\":1,\"18\":1,\"37\":1,\"43\":2}}],[\">=\",{\"1\":{\"95\":3,\"98\":1,\"109\":1,\"110\":1}}],[\">递归代码比较简洁\",{\"1\":{\"71\":1}}],[\">node\",{\"1\":{\"30\":3}}],[\">first=3\",{\"1\":{\"26\":1,\"27\":1}}],[\">\",{\"1\":{\"17\":1,\"18\":1,\"26\":1,\"27\":1,\"35\":1,\"43\":1,\"98\":1}}],[\"将str压入s1\",{\"1\":{\"98\":1}}],[\"将s1剩余运算符加入s2\",{\"1\":{\"98\":1}}],[\"将s1栈顶弹出压入s2\",{\"1\":{\"98\":1}}],[\"将s1栈顶的运算符弹出并压入到s2中\",{\"1\":{\"97\":1}}],[\"将s1中剩余的运算符依次弹出并压入s2\",{\"1\":{\"97\":1}}],[\"将其压s2\",{\"1\":{\"97\":1}}],[\"将\",{\"1\":{\"96\":4,\"98\":5}}],[\"将5入栈\",{\"1\":{\"96\":1}}],[\"将3和4压入堆栈\",{\"1\":{\"96\":1}}],[\"将35入栈\",{\"1\":{\"92\":1,\"96\":1}}],[\"将得到结果\",{\"1\":{\"93\":1,\"95\":2}}],[\"将6入栈\",{\"1\":{\"96\":1}}],[\"将6\",{\"1\":{\"92\":1}}],[\"将数字压入堆栈\",{\"1\":{\"92\":1,\"96\":1}}],[\"将非0数据添加进稀疏数组\",{\"1\":{\"85\":1}}],[\"将二维数组转稀疏数组\",{\"1\":{\"85\":1}}],[\"将皇后摆放的位置输出\",{\"1\":{\"80\":1}}],[\"将用栈解决的问题\",{\"1\":{\"71\":1}}],[\"将这个数组使用算法\",{\"1\":{\"56\":1}}],[\"将尾指针往后移\",{\"1\":{\"47\":1}}],[\"将对应节点的name修改\",{\"1\":{\"37\":1}}],[\"将最后一个节点的next指向新节点即添加成功\",{\"1\":{\"34\":1}}],[\"将最后节点的next指向新的节点\",{\"1\":{\"13\":1,\"18\":1,\"43\":1}}],[\"将first赋值为编号1的boy\",{\"1\":{\"24\":1}}],[\"将node的\",{\"1\":{\"17\":1}}],[\"将node的下一个节点指向temp的下一个节点\",{\"1\":{\"17\":1}}],[\"将temp下一节点指向node\",{\"1\":{\"17\":1}}],[\"将temp下一个节点的pre指向node\",{\"1\":{\"17\":1}}],[\"修改失败\",{\"1\":{\"16\":1,\"18\":1,\"37\":1,\"43\":1}}],[\"修改思路和原来的单向链表一样\",{\"1\":{\"9\":1}}],[\"都是找到节点然后直接修改\",{\"1\":{\"16\":1}}],[\"判断ch是数字还是符号\",{\"1\":{\"95\":1}}],[\"判断字符是操作符还是数字\",{\"1\":{\"94\":1}}],[\"判断队空\",{\"1\":{\"53\":1,\"54\":1,\"55\":3,\"65\":1,\"67\":3}}],[\"判断队满\",{\"1\":{\"52\":1,\"55\":1,\"64\":1,\"67\":1}}],[\"判断k\",{\"1\":{\"40\":1,\"43\":1}}],[\"判断2是否已经存在\",{\"1\":{\"35\":1}}],[\"判断是否是运算符\",{\"1\":{\"94\":1,\"95\":1}}],[\"判断是否已经存在\",{\"1\":{\"17\":1,\"18\":1,\"43\":1}}],[\"判断是否找到\",{\"1\":{\"14\":1,\"16\":1,\"18\":2,\"36\":1,\"37\":1,\"43\":2}}],[\"判空\",{\"1\":{\"15\":1,\"18\":1,\"40\":1,\"41\":1,\"43\":2}}],[\"遍历栈\",{\"1\":{\"95\":1,\"109\":1,\"110\":1,\"117\":1,\"118\":1}}],[\"遍历栈即可得到逆序\",{\"1\":{\"42\":1}}],[\"遍历输出稀疏数组\",{\"1\":{\"85\":1}}],[\"遍历输出原始二维数组\",{\"1\":{\"85\":2}}],[\"遍历二维数组\",{\"1\":{\"85\":1}}],[\"遍历二位数组得到非0数据个数\",{\"1\":{\"85\":1}}],[\"遍历稀疏数组填充二维数组\",{\"1\":{\"85\":1}}],[\"遍历length\",{\"1\":{\"43\":1}}],[\"遍历完毕\",{\"1\":{\"25\":1,\"27\":1}}],[\"遍历所有节点\",{\"0\":{\"25\":1}}],[\"遍历双向链表\",{\"1\":{\"15\":1,\"18\":1}}],[\"遍历\",{\"0\":{\"15\":1,\"109\":1,\"117\":1}}],[\"遍历和单链表一样\",{\"1\":{\"9\":1}}],[\"删除head的next即可\",{\"1\":{\"116\":1}}],[\"删除失败\",{\"1\":{\"14\":1,\"18\":1,\"36\":1,\"43\":1}}],[\"删除节点\",{\"1\":{\"14\":1,\"18\":1,\"36\":1,\"43\":1}}],[\"删除节点时候需将待删除节点的上一个节点的next指向待删除节点的下一个节点\",{\"1\":{\"14\":1}}],[\"filo\",{\"1\":{\"101\":2}}],[\"first指向出圈\",{\"1\":{\"27\":1}}],[\"first指向的2出圈\",{\"1\":{\"26\":1}}],[\"first=1\",{\"1\":{\"26\":2,\"27\":2}}],[\"first=2\",{\"1\":{\"26\":1}}],[\"first\",{\"1\":{\"24\":6,\"25\":3,\"26\":14,\"27\":23,\"101\":1,\"102\":1}}],[\"first报数时移动到报数为m的位置\",{\"1\":{\"21\":1}}],[\"front不再指向队列头部数据前一个位置\",{\"1\":{\"59\":1}}],[\"front++\",{\"1\":{\"53\":1,\"55\":1}}],[\"front\",{\"1\":{\"47\":3,\"49\":2,\"50\":2,\"53\":1,\"54\":1,\"55\":7,\"59\":5,\"61\":2,\"62\":2,\"63\":2,\"65\":3,\"66\":1,\"67\":13}}],[\"four\",{\"1\":{\"43\":1}}],[\"foreach\",{\"1\":{\"42\":1,\"43\":1}}],[\"for\",{\"1\":{\"3\":2,\"4\":1,\"24\":1,\"26\":2,\"27\":3,\"40\":1,\"43\":1,\"55\":1,\"67\":1,\"74\":2,\"75\":2,\"77\":4,\"80\":3,\"85\":7,\"95\":1,\"96\":1,\"98\":2,\"109\":1,\"110\":1}}],[\"false\",{\"1\":{\"14\":1,\"16\":1,\"17\":1,\"18\":3,\"35\":1,\"36\":1,\"37\":1,\"43\":3,\"76\":2,\"77\":2,\"80\":1}}],[\"无法删除\",{\"1\":{\"14\":1,\"18\":1}}],[\"operstack\",{\"1\":{\"95\":13}}],[\"oper\",{\"1\":{\"94\":7,\"95\":12,\"98\":5}}],[\"ok\",{\"1\":{\"79\":2}}],[\"out\",{\"1\":{\"14\":2,\"15\":1,\"16\":2,\"17\":1,\"18\":8,\"24\":1,\"25\":3,\"26\":3,\"27\":7,\"35\":1,\"36\":1,\"37\":2,\"42\":1,\"43\":11,\"52\":1,\"55\":6,\"64\":1,\"67\":6,\"75\":2,\"77\":3,\"80\":3,\"85\":6,\"95\":3,\"96\":1,\"98\":1,\"101\":1,\"107\":1,\"109\":1,\"110\":2,\"115\":1,\"117\":1,\"118\":2}}],[\"override\",{\"1\":{\"11\":1,\"18\":1,\"32\":1,\"43\":1}}],[\"s1\",{\"1\":{\"98\":11}}],[\"s2\",{\"1\":{\"98\":7}}],[\"s\",{\"1\":{\"96\":7,\"98\":15}}],[\"suffixcal\",{\"1\":{\"96\":1,\"98\":2}}],[\"substring\",{\"1\":{\"95\":3}}],[\"sum++\",{\"1\":{\"85\":1}}],[\"sum\",{\"1\":{\"85\":4}}],[\"switch\",{\"1\":{\"94\":1,\"95\":1}}],[\"sparse\",{\"1\":{\"85\":1}}],[\"sparsearr\",{\"1\":{\"85\":14}}],[\"sparsearray\",{\"0\":{\"124\":1},\"1\":{\"85\":1}}],[\"setway\",{\"1\":{\"76\":5,\"77\":6}}],[\"showqueue\",{\"1\":{\"55\":4,\"67\":5}}],[\"showboy\",{\"1\":{\"25\":1,\"27\":2}}],[\"showlist\",{\"1\":{\"15\":1,\"18\":4,\"43\":6}}],[\"size\",{\"1\":{\"66\":1,\"67\":4}}],[\"singlelinkedlist\",{\"1\":{\"33\":1,\"43\":3}}],[\"si\",{\"1\":{\"18\":3}}],[\"san\",{\"1\":{\"18\":3}}],[\"str是数字入s2\",{\"1\":{\"98\":1}}],[\"str\",{\"1\":{\"98\":12}}],[\"stringlist\",{\"1\":{\"98\":3}}],[\"strings\",{\"1\":{\"98\":3}}],[\"stringtolist\",{\"1\":{\"98\":2}}],[\"stringbuilder\",{\"1\":{\"95\":3,\"98\":2}}],[\"string\",{\"1\":{\"11\":3,\"18\":4,\"27\":1,\"32\":3,\"43\":4,\"55\":1,\"67\":1,\"77\":1,\"80\":1,\"85\":1,\"95\":2,\"96\":1,\"98\":7,\"110\":1,\"118\":1}}],[\"stack<string>\",{\"1\":{\"96\":1,\"98\":2}}],[\"stack<>\",{\"1\":{\"42\":1,\"43\":1,\"96\":1,\"98\":2}}],[\"stack<node>\",{\"1\":{\"42\":1,\"43\":1}}],[\"stack\",{\"0\":{\"125\":1},\"1\":{\"42\":3,\"43\":3,\"94\":1,\"95\":6,\"96\":6,\"98\":6,\"101\":2,\"104\":2,\"107\":1,\"108\":1,\"109\":1,\"110\":5}}],[\"startno=1\",{\"1\":{\"26\":1,\"27\":1}}],[\"startno\",{\"1\":{\"26\":5,\"27\":5}}],[\"static\",{\"1\":{\"18\":1,\"27\":1,\"43\":1,\"55\":1,\"67\":1,\"74\":1,\"75\":1,\"76\":1,\"77\":4,\"80\":1,\"85\":2,\"95\":1,\"96\":1,\"98\":5,\"110\":1,\"118\":1}}],[\"system\",{\"1\":{\"14\":2,\"15\":1,\"16\":2,\"17\":1,\"18\":8,\"24\":1,\"25\":3,\"26\":3,\"27\":7,\"35\":1,\"36\":1,\"37\":2,\"42\":1,\"43\":11,\"52\":1,\"55\":6,\"64\":1,\"67\":6,\"75\":2,\"77\":3,\"80\":3,\"85\":6,\"95\":3,\"96\":1,\"98\":1,\"107\":1,\"109\":1,\"110\":2,\"115\":1,\"117\":1,\"118\":2}}],[\"do\",{\"1\":{\"98\":1}}],[\"doublelinkedlist\",{\"1\":{\"12\":1,\"18\":3}}],[\"doublenode\",{\"1\":{\"11\":6,\"12\":2,\"13\":2,\"14\":1,\"15\":1,\"16\":2,\"17\":2,\"18\":24}}],[\"d+\",{\"1\":{\"96\":1,\"98\":2}}],[\"depth\",{\"1\":{\"102\":1}}],[\"default\",{\"1\":{\"94\":1,\"95\":1}}],[\"delbyage\",{\"1\":{\"14\":1,\"18\":2,\"36\":1,\"43\":2}}],[\"d\",{\"1\":{\"55\":1,\"67\":1,\"75\":1,\"77\":1,\"85\":1}}],[\"data\",{\"1\":{\"30\":1}}],[\"bottom\",{\"1\":{\"101\":1}}],[\"boy\",{\"1\":{\"23\":3,\"24\":9,\"25\":1,\"26\":1,\"27\":14}}],[\"boolean\",{\"1\":{\"14\":1,\"16\":1,\"17\":1,\"18\":3,\"35\":1,\"36\":1,\"37\":1,\"43\":3,\"50\":1,\"51\":1,\"55\":2,\"62\":1,\"63\":1,\"67\":2,\"76\":1,\"77\":2,\"80\":1,\"94\":1,\"95\":3,\"105\":1,\"106\":1,\"110\":2,\"114\":2,\"118\":2}}],[\"break\",{\"1\":{\"13\":1,\"14\":2,\"15\":1,\"16\":2,\"17\":3,\"18\":9,\"25\":1,\"26\":2,\"27\":3,\"34\":1,\"35\":3,\"36\":2,\"37\":2,\"43\":9,\"94\":5,\"95\":8,\"117\":1,\"118\":1}}],[\"bug制造者\",{\"1\":{\"0\":1}}],[\"while\",{\"1\":{\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"17\":1,\"18\":5,\"25\":1,\"26\":2,\"27\":3,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"39\":1,\"41\":1,\"42\":1,\"43\":8,\"95\":3,\"98\":5,\"117\":1,\"118\":1}}],[\"append\",{\"1\":{\"95\":2,\"98\":1}}],[\"abs\",{\"1\":{\"80\":4}}],[\"article\",{\"0\":{\"120\":1}}],[\"arraystack\",{\"1\":{\"104\":2,\"110\":12}}],[\"arraylist<>\",{\"1\":{\"98\":2}}],[\"arraylist<string>\",{\"1\":{\"98\":1}}],[\"arraylist\",{\"1\":{\"98\":4}}],[\"array\",{\"1\":{\"80\":11,\"85\":3}}],[\"arrayqueue\",{\"1\":{\"49\":1,\"55\":14}}],[\"arr\",{\"1\":{\"49\":2,\"52\":1,\"53\":1,\"54\":1,\"55\":6,\"61\":2,\"64\":1,\"65\":1,\"67\":6,\"79\":3}}],[\"args\",{\"1\":{\"18\":1,\"27\":1,\"43\":1,\"55\":1,\"67\":1,\"77\":1,\"80\":1,\"85\":1,\"95\":1,\"98\":1,\"110\":1,\"118\":1}}],[\"addqueue\",{\"1\":{\"47\":1,\"52\":1,\"55\":5,\"64\":1,\"67\":5}}],[\"addboy\",{\"1\":{\"24\":1,\"27\":2}}],[\"addbyage\",{\"1\":{\"17\":1,\"18\":2,\"35\":1,\"43\":2}}],[\"add\",{\"1\":{\"13\":1,\"18\":4,\"34\":1,\"43\":4,\"98\":7}}],[\"age=\",{\"1\":{\"11\":1,\"18\":1,\"32\":1,\"43\":1}}],[\"age\",{\"1\":{\"11\":5,\"14\":3,\"16\":2,\"17\":4,\"18\":14,\"32\":5,\"35\":4,\"36\":3,\"37\":2,\"43\":14}}],[\"顺序添加节点\",{\"0\":{\"13\":1,\"34\":1},\"1\":{\"13\":1,\"18\":1,\"34\":1,\"43\":1}}],[\"headqueue\",{\"1\":{\"54\":1,\"55\":2,\"67\":2}}],[\"head\",{\"1\":{\"12\":1,\"13\":1,\"14\":2,\"15\":2,\"16\":2,\"17\":1,\"18\":9,\"30\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":2,\"39\":2,\"40\":2,\"41\":8,\"42\":2,\"43\":22,\"55\":2,\"67\":2,\"113\":1,\"115\":2,\"116\":2,\"117\":1,\"118\":6}}],[\"hashmap<>\",{\"1\":{\"4\":1}}],[\"默认是null\",{\"1\":{\"11\":2,\"18\":2}}],[\"默认添加到双向链表的最后\",{\"1\":{\"9\":1}}],[\"c是数字\",{\"1\":{\"98\":1}}],[\"c\",{\"1\":{\"98\":7}}],[\"case\",{\"1\":{\"94\":4,\"95\":4}}],[\"calstack\",{\"1\":{\"95\":6}}],[\"calculator\",{\"1\":{\"95\":1}}],[\"cal\",{\"1\":{\"94\":2,\"95\":3}}],[\"ch\",{\"1\":{\"95\":10}}],[\"charat\",{\"1\":{\"95\":3,\"98\":4}}],[\"char\",{\"1\":{\"94\":1,\"95\":2,\"98\":1}}],[\"chess\",{\"1\":{\"85\":3}}],[\"chessarr\",{\"1\":{\"85\":13}}],[\"check\",{\"1\":{\"80\":3}}],[\"circlearrayqueue\",{\"1\":{\"61\":1,\"67\":4}}],[\"circlesinglelinkedlist\",{\"1\":{\"24\":1,\"27\":3}}],[\"count0即为空\",{\"1\":{\"114\":1}}],[\"countmaxsize即为满\",{\"1\":{\"114\":1}}],[\"count用于记录栈中元素个数\",{\"1\":{\"113\":1}}],[\"count++\",{\"1\":{\"80\":1,\"85\":1,\"115\":1,\"118\":1}}],[\"count\",{\"1\":{\"80\":2,\"85\":4,\"113\":1,\"114\":2,\"116\":1,\"118\":4}}],[\"countboy\",{\"1\":{\"26\":1,\"27\":2}}],[\"countnum\",{\"1\":{\"26\":3,\"27\":3}}],[\"containskey\",{\"1\":{\"4\":1}}],[\"cur=1\",{\"1\":{\"43\":1}}],[\"cur=3\",{\"1\":{\"41\":1,\"43\":1}}],[\"cur=2\",{\"1\":{\"41\":1,\"43\":1}}],[\"cur\",{\"1\":{\"25\":5,\"27\":5,\"39\":4,\"40\":4,\"41\":6,\"42\":5,\"43\":19}}],[\"class\",{\"1\":{\"11\":1,\"12\":1,\"18\":2,\"23\":1,\"24\":1,\"27\":3,\"32\":1,\"33\":1,\"43\":2,\"55\":1,\"67\":1,\"77\":1,\"80\":1,\"85\":1,\"95\":2,\"98\":1,\"104\":1,\"110\":1,\"112\":1,\"113\":1,\"118\":2}}],[\"因此是num2\",{\"1\":{\"94\":1}}],[\"因此弹出\",{\"1\":{\"96\":2,\"98\":2}}],[\"因此弹出5和7\",{\"1\":{\"96\":1}}],[\"因此弹出4和3\",{\"1\":{\"96\":1}}],[\"因此弹出7和5\",{\"1\":{\"92\":1}}],[\"因此弹出3和4\",{\"1\":{\"92\":1}}],[\"因此记录为2\",{\"1\":{\"84\":1}}],[\"因此记录了很多没有意义的数据\",{\"1\":{\"83\":1}}],[\"因此可以使用稀疏数组来记录信息\",{\"1\":{\"83\":1}}],[\"因此可以实现自我删除某个节点\",{\"1\":{\"9\":1}}],[\"因此将数组看做是一个环形的\",{\"1\":{\"58\":1}}],[\"因此需要两个变量\",{\"1\":{\"47\":1}}],[\"因为count作为计数器所以满与空只用判断count即可\",{\"1\":{\"114\":1}}],[\"因为索引从0开始\",{\"1\":{\"105\":1}}],[\"因为该二维数组的很多值是默认值\",{\"1\":{\"83\":1}}],[\"因为n在递增故不需要判断在同一行\",{\"1\":{\"80\":1}}],[\"因为将队列容量空出一个作为约定\",{\"1\":{\"59\":1}}],[\"因为队列的输出\",{\"1\":{\"47\":1}}],[\"因为本身\",{\"1\":{\"26\":1,\"27\":1}}],[\"因为本身已经在第一位了\",{\"1\":{\"26\":1,\"27\":1}}],[\"因为是双向链表所以有pre和next\",{\"1\":{\"11\":1}}],[\"因为是双向链表\",{\"1\":{\"9\":1}}],[\"polandnotation\",{\"1\":{\"98\":1}}],[\"pop类似于弹夹弹出子弹\",{\"1\":{\"108\":1}}],[\"pop\",{\"1\":{\"95\":14,\"96\":3,\"98\":7,\"101\":1,\"108\":1,\"110\":2,\"116\":1,\"118\":2}}],[\"parsesuffixexp\",{\"1\":{\"98\":2}}],[\"parseint\",{\"1\":{\"95\":1,\"96\":2,\"98\":2}}],[\"param\",{\"1\":{\"26\":3,\"27\":3,\"76\":3,\"77\":3,\"98\":2}}],[\"peek只得到数字而不弹出\",{\"1\":{\"94\":1}}],[\"peek\",{\"1\":{\"94\":2,\"95\":2,\"98\":2}}],[\"problem\",{\"1\":{\"72\":1}}],[\"priority\",{\"1\":{\"94\":2,\"95\":3,\"98\":3}}],[\"printarray\",{\"1\":{\"85\":4}}],[\"print\",{\"1\":{\"80\":2}}],[\"printmap\",{\"1\":{\"75\":1,\"77\":3}}],[\"printf\",{\"1\":{\"55\":1,\"67\":1,\"75\":1,\"77\":1,\"80\":1,\"85\":1}}],[\"println\",{\"1\":{\"14\":2,\"15\":1,\"16\":2,\"17\":1,\"18\":8,\"24\":1,\"25\":3,\"26\":3,\"27\":7,\"35\":1,\"36\":1,\"37\":2,\"42\":1,\"43\":11,\"52\":1,\"55\":5,\"64\":1,\"67\":5,\"75\":1,\"77\":2,\"80\":2,\"85\":5,\"95\":3,\"96\":1,\"98\":1,\"107\":1,\"109\":1,\"110\":2,\"115\":1,\"117\":1,\"118\":2}}],[\"private\",{\"1\":{\"12\":1,\"18\":1,\"24\":1,\"27\":1,\"33\":1,\"43\":1,\"49\":4,\"55\":4,\"61\":4,\"67\":4,\"74\":1,\"75\":1,\"77\":2,\"80\":3,\"85\":1,\"95\":3,\"104\":3,\"110\":3,\"113\":3,\"118\":3}}],[\"pre\",{\"1\":{\"9\":4,\"11\":1,\"13\":1,\"14\":9,\"17\":2,\"18\":7}}],[\"push\",{\"1\":{\"42\":1,\"43\":1,\"95\":7,\"96\":2,\"98\":3,\"101\":1,\"107\":1,\"110\":6,\"115\":1,\"118\":6}}],[\"put\",{\"1\":{\"4\":1}}],[\"public\",{\"1\":{\"3\":1,\"4\":1,\"11\":7,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"16\":1,\"17\":1,\"18\":14,\"23\":3,\"24\":1,\"25\":1,\"26\":1,\"27\":8,\"32\":6,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"43\":17,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":8,\"61\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":10,\"76\":1,\"77\":3,\"80\":2,\"85\":2,\"94\":4,\"95\":12,\"96\":1,\"98\":6,\"104\":2,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":8,\"112\":4,\"113\":2,\"114\":2,\"115\":1,\"116\":1,\"117\":1,\"118\":12}}],[\"添加数据\",{\"0\":{\"52\":1,\"64\":1},\"1\":{\"52\":1,\"55\":1,\"64\":1,\"67\":1}}],[\"添加小孩节点\",{\"1\":{\"24\":1,\"27\":1}}],[\"添加\",{\"1\":{\"9\":1}}],[\"查找的方向只能是一个方向\",{\"1\":{\"8\":1}}],[\"单位数字直接入栈\",{\"1\":{\"95\":1}}],[\"单向环形链表应用场景\",{\"0\":{\"21\":1}}],[\"单向链表不能自我删除\",{\"1\":{\"8\":1}}],[\"单向链表\",{\"1\":{\"8\":1}}],[\"单链表初始化\",{\"0\":{\"33\":1}}],[\"单链表需要找到删除节点的前一个节点\",{\"1\":{\"14\":2,\"18\":1}}],[\"单链表缺点\",{\"0\":{\"8\":1}}],[\"单链表\",{\"0\":{\"29\":1},\"1\":{\"1\":1,\"30\":1}}],[\"双向链表为空\",{\"1\":{\"14\":1,\"16\":1,\"18\":2}}],[\"双向链表\",{\"0\":{\"7\":1,\"9\":1},\"1\":{\"9\":1}}],[\"双链表\",{\"1\":{\"1\":1}}],[\"getqueue\",{\"1\":{\"53\":1,\"55\":2,\"65\":1,\"67\":2}}],[\"getlastk\",{\"1\":{\"40\":1,\"43\":2}}],[\"getlength\",{\"1\":{\"39\":1,\"40\":1,\"43\":3}}],[\"get\",{\"1\":{\"4\":1}}],[\"哈希法\",{\"0\":{\"4\":1}}],[\"方法二\",{\"0\":{\"4\":1},\"1\":{\"42\":1,\"43\":1}}],[\"方法一\",{\"0\":{\"3\":1},\"1\":{\"42\":1,\"43\":1}}],[\"n+1\",{\"1\":{\"84\":1}}],[\"no\",{\"1\":{\"23\":4,\"25\":1,\"26\":2,\"27\":7}}],[\"node4\",{\"1\":{\"43\":2}}],[\"node3\",{\"1\":{\"43\":4}}],[\"node2\",{\"1\":{\"43\":2}}],[\"node1\",{\"1\":{\"43\":2}}],[\"node节点\",{\"0\":{\"32\":1}}],[\"node\",{\"1\":{\"13\":3,\"16\":3,\"17\":7,\"18\":13,\"32\":5,\"33\":2,\"34\":4,\"35\":7,\"36\":1,\"37\":5,\"39\":1,\"40\":2,\"41\":4,\"42\":1,\"43\":43,\"112\":4,\"113\":2,\"115\":5,\"116\":1,\"117\":1,\"118\":13}}],[\"n=5\",{\"1\":{\"21\":1}}],[\"n\",{\"1\":{\"21\":2,\"76\":1,\"77\":1,\"80\":13,\"84\":1}}],[\"name=\",{\"1\":{\"11\":1,\"18\":1,\"32\":1,\"43\":1}}],[\"name\",{\"1\":{\"11\":5,\"16\":2,\"18\":7,\"32\":5,\"37\":2,\"43\":7}}],[\"next=node\",{\"1\":{\"115\":1}}],[\"next=head\",{\"1\":{\"115\":1}}],[\"next=2\",{\"1\":{\"41\":1,\"43\":1}}],[\"next==2\",{\"1\":{\"36\":1}}],[\"next=first\",{\"1\":{\"26\":1}}],[\"next=first保持环形\",{\"1\":{\"24\":1}}],[\"next和\",{\"1\":{\"14\":1}}],[\"next\",{\"1\":{\"9\":4,\"11\":1,\"13\":3,\"14\":12,\"15\":3,\"16\":3,\"17\":9,\"18\":26,\"23\":1,\"24\":3,\"25\":2,\"26\":8,\"27\":14,\"30\":1,\"32\":1,\"34\":3,\"35\":7,\"36\":6,\"37\":3,\"39\":3,\"40\":3,\"41\":13,\"42\":3,\"43\":45,\"112\":1,\"115\":4,\"116\":6,\"117\":2,\"118\":12}}],[\"newhead\",{\"1\":{\"41\":4,\"43\":4}}],[\"newnode\",{\"1\":{\"9\":2}}],[\"new\",{\"1\":{\"3\":1,\"4\":2,\"12\":1,\"18\":6,\"24\":1,\"27\":2,\"33\":1,\"41\":1,\"42\":1,\"43\":9,\"49\":1,\"53\":1,\"54\":1,\"55\":4,\"61\":1,\"65\":1,\"67\":4,\"74\":1,\"77\":1,\"80\":2,\"85\":3,\"95\":7,\"96\":1,\"98\":5,\"104\":1,\"108\":1,\"109\":1,\"110\":4,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":5}}],[\"num2\",{\"1\":{\"94\":6,\"95\":10,\"96\":6,\"98\":6}}],[\"num1\",{\"1\":{\"94\":11,\"95\":14,\"96\":6,\"98\":6}}],[\"num\",{\"1\":{\"4\":3,\"52\":2,\"55\":4,\"64\":2,\"65\":2,\"67\":6,\"85\":1,\"95\":4,\"107\":2,\"108\":2,\"110\":4,\"115\":2,\"118\":2}}],[\"numstack\",{\"1\":{\"95\":11}}],[\"nums值不正确\",{\"1\":{\"24\":1,\"27\":1}}],[\"nums个小孩\",{\"1\":{\"24\":1,\"27\":1}}],[\"nums\",{\"1\":{\"3\":5,\"4\":4,\"24\":3,\"26\":3,\"27\":6}}],[\"null\",{\"1\":{\"3\":1,\"4\":1,\"13\":1,\"14\":3,\"15\":2,\"16\":2,\"17\":1,\"18\":9,\"24\":2,\"25\":1,\"26\":1,\"27\":4,\"34\":1,\"35\":1,\"36\":1,\"37\":2,\"39\":2,\"40\":3,\"41\":11,\"42\":2,\"43\":25,\"117\":1,\"118\":1}}],[\"+14\",{\"1\":{\"89\":1}}],[\"+\",{\"1\":{\"3\":1,\"11\":6,\"18\":6,\"25\":1,\"26\":2,\"27\":3,\"32\":6,\"43\":8,\"54\":1,\"55\":4,\"59\":3,\"63\":2,\"64\":1,\"65\":1,\"66\":1,\"67\":8,\"76\":2,\"77\":3,\"80\":4,\"85\":2,\"89\":1,\"90\":4,\"91\":4,\"94\":4,\"95\":10,\"96\":5,\"98\":11}}],[\"judge\",{\"1\":{\"80\":2}}],[\"josephu\",{\"1\":{\"21\":2,\"27\":1}}],[\"j++\",{\"1\":{\"3\":1,\"75\":1,\"77\":1,\"85\":2}}],[\"j\",{\"1\":{\"3\":5,\"75\":3,\"76\":10,\"77\":13,\"85\":8}}],[\"<=\",{\"1\":{\"24\":1,\"27\":1,\"55\":1,\"95\":1,\"98\":2}}],[\"<\",{\"1\":{\"3\":2,\"4\":1,\"24\":1,\"26\":3,\"27\":4,\"40\":3,\"43\":3,\"67\":1,\"74\":2,\"75\":2,\"77\":4,\"80\":2,\"85\":5,\"94\":1,\"95\":1,\"98\":3}}],[\"0代表可走的路\",{\"1\":{\"72\":1}}],[\"0\",{\"1\":{\"3\":2,\"4\":1,\"26\":2,\"27\":2,\"39\":1,\"40\":1,\"43\":2,\"61\":2,\"67\":2,\"72\":45,\"74\":4,\"75\":2,\"76\":1,\"77\":7,\"79\":1,\"80\":4,\"83\":1,\"85\":18,\"94\":3,\"95\":8,\"96\":1,\"98\":3,\"109\":1,\"110\":1,\"113\":1,\"114\":1,\"118\":2}}],[\"=>\",{\"1\":{\"98\":1}}],[\"=0表示没走过\",{\"1\":{\"76\":1,\"77\":1}}],[\"==\",{\"1\":{\"3\":1,\"13\":1,\"14\":3,\"15\":2,\"16\":3,\"17\":2,\"18\":11,\"24\":1,\"25\":2,\"26\":3,\"27\":6,\"34\":1,\"35\":2,\"36\":2,\"37\":3,\"39\":1,\"40\":1,\"41\":2,\"42\":1,\"43\":15,\"47\":2,\"50\":2,\"51\":2,\"55\":4,\"59\":4,\"62\":2,\"63\":2,\"67\":4,\"76\":2,\"77\":2,\"80\":5,\"94\":8,\"95\":10,\"105\":1,\"106\":1,\"110\":2,\"114\":2,\"117\":1,\"118\":3}}],[\"=\",{\"1\":{\"3\":3,\"4\":4,\"9\":4,\"11\":2,\"12\":1,\"13\":4,\"14\":11,\"15\":2,\"16\":5,\"17\":8,\"18\":34,\"23\":1,\"24\":10,\"25\":2,\"26\":10,\"27\":24,\"32\":2,\"33\":1,\"34\":3,\"35\":6,\"36\":5,\"37\":5,\"39\":4,\"40\":4,\"41\":9,\"42\":4,\"43\":51,\"49\":4,\"52\":1,\"55\":9,\"61\":4,\"64\":2,\"65\":2,\"67\":14,\"74\":9,\"75\":2,\"76\":2,\"77\":15,\"79\":2,\"80\":7,\"85\":21,\"94\":6,\"95\":28,\"96\":8,\"98\":20,\"104\":3,\"107\":1,\"108\":1,\"109\":1,\"110\":7,\"112\":1,\"113\":3,\"115\":3,\"116\":2,\"117\":2,\"118\":12}}],[\"in\",{\"1\":{\"101\":1}}],[\"initmap\",{\"1\":{\"74\":1,\"77\":2}}],[\"index++\",{\"1\":{\"95\":2,\"98\":2}}],[\"index\",{\"1\":{\"67\":2,\"95\":9,\"98\":7}}],[\"integer\",{\"1\":{\"95\":1,\"96\":2,\"98\":2}}],[\"integer>\",{\"1\":{\"4\":1}}],[\"int\",{\"1\":{\"3\":6,\"4\":7,\"11\":2,\"14\":1,\"18\":3,\"23\":2,\"24\":2,\"26\":5,\"27\":9,\"32\":2,\"36\":1,\"39\":2,\"40\":3,\"43\":8,\"49\":6,\"52\":1,\"53\":1,\"54\":1,\"55\":12,\"61\":6,\"64\":1,\"65\":2,\"66\":1,\"67\":16,\"74\":5,\"75\":3,\"76\":3,\"77\":12,\"80\":9,\"85\":16,\"94\":8,\"95\":22,\"96\":1,\"98\":3,\"104\":5,\"107\":1,\"108\":2,\"109\":1,\"110\":9,\"112\":2,\"113\":3,\"115\":1,\"116\":1,\"118\":7}}],[\"isoper\",{\"1\":{\"94\":2,\"95\":3}}],[\"isfull\",{\"1\":{\"51\":1,\"52\":1,\"55\":2,\"63\":1,\"64\":1,\"67\":2,\"95\":2,\"105\":1,\"107\":1,\"110\":2,\"114\":1,\"115\":1,\"118\":2}}],[\"isfind\",{\"1\":{\"14\":3,\"16\":3,\"18\":6,\"36\":3,\"37\":3,\"43\":6}}],[\"isexit\",{\"1\":{\"77\":2}}],[\"isexist\",{\"1\":{\"17\":3,\"18\":3,\"35\":3,\"43\":3}}],[\"isempty\",{\"1\":{\"50\":1,\"53\":1,\"54\":1,\"55\":4,\"62\":1,\"65\":1,\"67\":4,\"95\":5,\"98\":2,\"106\":1,\"108\":1,\"109\":1,\"110\":3,\"114\":1,\"116\":1,\"117\":1,\"118\":3}}],[\"if\",{\"1\":{\"3\":1,\"4\":1,\"13\":1,\"14\":5,\"15\":2,\"16\":4,\"17\":4,\"18\":16,\"24\":2,\"25\":2,\"26\":3,\"27\":7,\"34\":1,\"35\":4,\"36\":3,\"37\":4,\"39\":1,\"40\":2,\"41\":1,\"42\":1,\"43\":19,\"52\":1,\"53\":1,\"54\":1,\"55\":4,\"64\":1,\"65\":1,\"67\":4,\"76\":6,\"77\":6,\"80\":3,\"85\":2,\"94\":2,\"95\":11,\"96\":5,\"98\":11,\"107\":1,\"108\":1,\"109\":1,\"110\":3,\"115\":1,\"116\":1,\"117\":2,\"118\":4}}],[\"i++\",{\"1\":{\"3\":1,\"4\":1,\"24\":1,\"26\":2,\"27\":3,\"40\":1,\"43\":1,\"55\":1,\"67\":1,\"74\":2,\"75\":1,\"77\":3,\"80\":2,\"85\":3}}],[\"i\",{\"1\":{\"3\":5,\"4\":6,\"24\":4,\"26\":4,\"27\":8,\"40\":2,\"43\":2,\"55\":3,\"67\":3,\"74\":8,\"75\":3,\"76\":10,\"77\":21,\"79\":1,\"80\":13,\"85\":15,\"95\":4,\"109\":4,\"110\":4}}],[\"top++\",{\"1\":{\"95\":1,\"107\":1,\"110\":1}}],[\"top\",{\"1\":{\"94\":1,\"95\":8,\"101\":1,\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":2,\"109\":1,\"110\":7}}],[\"tostring\",{\"1\":{\"11\":1,\"18\":1,\"32\":1,\"43\":1,\"95\":1,\"98\":1}}],[\"t\",{\"1\":{\"55\":1,\"67\":1,\"75\":1,\"77\":1,\"85\":1}}],[\"throw\",{\"1\":{\"53\":1,\"54\":1,\"55\":2,\"65\":1,\"67\":2,\"95\":2,\"108\":1,\"109\":1,\"110\":2,\"116\":1,\"117\":1,\"118\":2}}],[\"this\",{\"1\":{\"11\":2,\"18\":2,\"23\":1,\"27\":1,\"32\":2,\"43\":2,\"49\":1,\"55\":1,\"61\":1,\"67\":1,\"95\":1,\"104\":1,\"110\":1,\"112\":1,\"113\":1,\"118\":2}}],[\"true\",{\"1\":{\"13\":1,\"14\":2,\"15\":1,\"16\":2,\"17\":2,\"18\":8,\"25\":1,\"26\":2,\"27\":3,\"34\":1,\"35\":2,\"36\":2,\"37\":2,\"43\":8,\"76\":5,\"77\":5,\"80\":1,\"95\":3,\"117\":1,\"118\":1}}],[\"temp如果是最后一个则不执行\",{\"1\":{\"14\":1,\"18\":1}}],[\"temp\",{\"1\":{\"8\":2,\"9\":7,\"13\":6,\"14\":16,\"15\":5,\"16\":6,\"17\":10,\"18\":37,\"34\":5,\"35\":8,\"36\":7,\"37\":6,\"43\":31,\"117\":5,\"118\":5}}],[\"target\",{\"1\":{\"3\":2,\"4\":2}}],[\"twosum\",{\"1\":{\"3\":1,\"4\":1}}],[\"穷举法\",{\"0\":{\"3\":1}}],[\"两数之和\",{\"0\":{\"2\":1},\"1\":{\"2\":1,\"6\":1}}],[\"递归有助于编程者解决复杂的问题\",{\"1\":{\"70\":1}}],[\"递归就是方法自己调用自己\",{\"1\":{\"70\":1}}],[\"递归\",{\"0\":{\"69\":1},\"1\":{\"1\":1},\"2\":{\"81\":1}}],[\"92种\",{\"1\":{\"78\":1}}],[\"9\",{\"1\":{\"1\":1,\"89\":1}}],[\"前缀表达式求值\",{\"0\":{\"92\":1}}],[\"前缀表达式为\",{\"1\":{\"90\":1}}],[\"前缀表达式\",{\"0\":{\"90\":1},\"1\":{\"90\":1}}],[\"前缀\",{\"0\":{\"87\":1,\"88\":1},\"1\":{\"1\":1}}],[\"8×8\",{\"1\":{\"78\":1}}],[\"8\",{\"1\":{\"1\":1,\"67\":1,\"74\":2,\"75\":1,\"77\":3,\"79\":2,\"80\":1,\"90\":2,\"91\":2,\"110\":1,\"118\":1}}],[\"栈需要指定大小maxsize\",{\"1\":{\"104\":1}}],[\"栈是一个\",{\"1\":{\"101\":1}}],[\"栈的应用场景\",{\"0\":{\"102\":1}}],[\"栈的英文为\",{\"1\":{\"101\":1}}],[\"栈的介绍\",{\"0\":{\"101\":1}}],[\"栈还得弹出\",{\"1\":{\"98\":1}}],[\"栈为空\",{\"1\":{\"95\":2,\"108\":1,\"109\":1,\"110\":2,\"116\":1,\"117\":1,\"118\":2}}],[\"栈已经满了\",{\"1\":{\"95\":1,\"107\":1,\"110\":1,\"115\":1,\"118\":1}}],[\"栈空\",{\"0\":{\"106\":1},\"1\":{\"95\":1,\"106\":1,\"110\":1,\"114\":1,\"118\":1}}],[\"栈满\",{\"0\":{\"105\":1},\"1\":{\"95\":1,\"105\":1,\"110\":1,\"114\":1,\"118\":1}}],[\"栈大小\",{\"1\":{\"95\":1,\"104\":1,\"110\":1,\"113\":1,\"118\":1}}],[\"栈顶\",{\"1\":{\"94\":1,\"96\":1}}],[\"栈顶和次栈\",{\"1\":{\"94\":1}}],[\"栈顶元素\",{\"1\":{\"92\":1,\"93\":1,\"96\":1}}],[\"栈先进后出\",{\"1\":{\"42\":1}}],[\"栈\",{\"0\":{\"100\":1},\"1\":{\"1\":1,\"42\":1,\"101\":1},\"2\":{\"99\":1,\"119\":1}}],[\"7×5=35\",{\"1\":{\"96\":1,\"98\":1}}],[\"7\",{\"1\":{\"1\":1,\"55\":1,\"67\":1,\"74\":3,\"75\":1,\"77\":4,\"79\":1,\"96\":1,\"98\":1}}],[\"环形链表\",{\"0\":{\"20\":1},\"1\":{\"1\":1,\"21\":1}}],[\"环形队列1\",{\"1\":{\"26\":1}}],[\"环形队列\",{\"0\":{\"58\":1},\"1\":{\"1\":1}}],[\"6是次顶\",{\"1\":{\"96\":1}}],[\"6的值\",{\"1\":{\"92\":1,\"96\":1}}],[\"6\",{\"1\":{\"1\":1,\"74\":1,\"76\":3,\"77\":4,\"79\":1,\"92\":1,\"93\":1,\"95\":1,\"96\":5,\"98\":11}}],[\"57\",{\"1\":{\"98\":2}}],[\"5个小孩\",{\"1\":{\"27\":1}}],[\"5\",{\"1\":{\"1\":1,\"21\":1,\"26\":1,\"27\":2,\"55\":1,\"67\":1,\"76\":3,\"77\":3,\"79\":1,\"92\":1,\"96\":4,\"98\":10,\"110\":2,\"118\":2}}],[\"48\",{\"1\":{\"98\":2}}],[\"4为栈顶元素\",{\"1\":{\"96\":1}}],[\"4为次顶元素\",{\"1\":{\"92\":1}}],[\"4代表出口\",{\"1\":{\"72\":1}}],[\"4\",{\"1\":{\"1\":1,\"18\":2,\"21\":1,\"26\":1,\"55\":1,\"67\":1,\"72\":1,\"79\":2,\"89\":1,\"90\":2,\"91\":2,\"92\":1,\"96\":5,\"98\":8}}],[\"35\",{\"1\":{\"96\":2,\"98\":2}}],[\"3为次顶元素\",{\"1\":{\"96\":1}}],[\"3为栈顶元素\",{\"1\":{\"92\":1}}],[\"36\",{\"1\":{\"95\":1}}],[\"3压入堆栈\",{\"1\":{\"92\":1}}],[\"3+4\",{\"1\":{\"92\":1,\"96\":2,\"98\":5}}],[\"32\",{\"1\":{\"89\":1}}],[\"3死路\",{\"1\":{\"76\":1,\"77\":1}}],[\"3表示已经走过但是走不通\",{\"1\":{\"76\":1,\"77\":1}}],[\"30\",{\"1\":{\"43\":2}}],[\"3变成1\",{\"1\":{\"36\":1,\"43\":1}}],[\"3>2\",{\"1\":{\"35\":1}}],[\"3之间变成1\",{\"1\":{\"35\":1,\"43\":1}}],[\"3\",{\"0\":{\"41\":1},\"1\":{\"1\":1,\"14\":1,\"18\":2,\"21\":1,\"26\":1,\"35\":2,\"36\":2,\"41\":4,\"43\":8,\"74\":4,\"76\":2,\"77\":4,\"79\":2,\"84\":1,\"85\":2,\"90\":4,\"91\":4,\"96\":5,\"98\":8,\"110\":1,\"118\":1}}],[\"数栈和符号栈中\",{\"1\":{\"95\":2}}],[\"数字直接入栈\",{\"1\":{\"96\":1}}],[\"数字栈pop出的第二个数字\",{\"1\":{\"95\":1}}],[\"数字栈pop出的第一个数字\",{\"1\":{\"95\":1}}],[\"数字栈\",{\"1\":{\"95\":1}}],[\"数字越大优先级越高\",{\"1\":{\"94\":1,\"95\":1}}],[\"数字1模拟墙\",{\"1\":{\"74\":1,\"77\":1}}],[\"数组模拟栈\",{\"0\":{\"103\":1}}],[\"数组模拟队列思路\",{\"0\":{\"47\":1}}],[\"数组来记录\",{\"1\":{\"84\":1}}],[\"数组\",{\"2\":{\"57\":1,\"68\":1,\"86\":1}}],[\"数组最大容量\",{\"1\":{\"49\":1,\"55\":1,\"61\":1,\"67\":1}}],[\"数组反转\",{\"0\":{\"41\":1},\"1\":{\"43\":1}}],[\"数组队列\",{\"0\":{\"45\":1},\"1\":{\"1\":1}}],[\"数到\",{\"1\":{\"21\":2}}],[\"数据存储\",{\"1\":{\"95\":1,\"104\":1,\"110\":1}}],[\"数据校验\",{\"1\":{\"26\":1,\"27\":1}}],[\"数据不存在\",{\"1\":{\"14\":1,\"16\":1,\"18\":2,\"36\":1,\"37\":1,\"43\":2}}],[\"数据结构与算法\",{\"0\":{\"1\":1}}],[\"29\",{\"1\":{\"96\":1,\"98\":1}}],[\"2则记录为2\",{\"1\":{\"84\":1}}],[\"2走过的路\",{\"1\":{\"76\":1,\"77\":1}}],[\"200\",{\"1\":{\"93\":1,\"95\":1}}],[\"20\",{\"1\":{\"43\":1,\"95\":2}}],[\"24153\",{\"1\":{\"27\":1}}],[\"2号出队\",{\"1\":{\"26\":1}}],[\"2=3\",{\"1\":{\"17\":1,\"18\":1}}],[\"2\",{\"0\":{\"41\":2},\"1\":{\"1\":1,\"18\":1,\"21\":2,\"24\":2,\"26\":2,\"27\":4,\"35\":3,\"36\":1,\"41\":5,\"43\":12,\"55\":1,\"72\":10,\"74\":2,\"76\":3,\"77\":4,\"79\":2,\"84\":2,\"85\":7,\"89\":1,\"90\":2,\"91\":2,\"93\":1,\"94\":1,\"95\":3,\"96\":1,\"98\":2,\"110\":1,\"118\":1}}],[\"稀疏数组还原二维数组\",{\"1\":{\"85\":1}}],[\"稀疏数组还原为二维数组\",{\"1\":{\"85\":1}}],[\"稀疏数组\",{\"0\":{\"82\":1},\"1\":{\"1\":1,\"84\":1}}],[\"1与s1中新的栈顶运算符相比较\",{\"1\":{\"97\":1}}],[\"13\",{\"1\":{\"90\":2,\"91\":2}}],[\"19\",{\"1\":{\"89\":1}}],[\"11\",{\"1\":{\"85\":6}}],[\"11的原始数组是11列\",{\"1\":{\"84\":1}}],[\"11的原始数组是11行\",{\"1\":{\"84\":1}}],[\"1墙\",{\"1\":{\"76\":1,\"77\":1}}],[\"1代表墙壁\",{\"1\":{\"72\":1}}],[\"100+20则是多位数\",{\"1\":{\"95\":1}}],[\"10\",{\"1\":{\"43\":1}}],[\"18\",{\"1\":{\"43\":2}}],[\"1位\",{\"1\":{\"26\":1,\"27\":1}}],[\"1位置因为本身得报一个数\",{\"1\":{\"26\":1}}],[\"1次\",{\"1\":{\"26\":2,\"27\":2}}],[\"1<=k<=n\",{\"1\":{\"21\":1}}],[\"1=2\",{\"1\":{\"17\":1,\"18\":1}}],[\"1=2=3变成1=3\",{\"1\":{\"14\":1,\"18\":1}}],[\"1=3\",{\"1\":{\"14\":1,\"18\":1}}],[\"1\",{\"0\":{\"2\":1,\"41\":2},\"1\":{\"1\":1,\"2\":1,\"6\":1,\"14\":1,\"18\":2,\"21\":3,\"24\":7,\"26\":4,\"27\":11,\"35\":1,\"36\":2,\"40\":1,\"41\":7,\"43\":14,\"47\":2,\"49\":2,\"51\":2,\"54\":1,\"55\":7,\"59\":2,\"63\":2,\"64\":1,\"65\":1,\"67\":5,\"72\":58,\"74\":8,\"76\":4,\"77\":13,\"79\":2,\"80\":1,\"84\":2,\"85\":9,\"94\":1,\"95\":9,\"96\":1,\"98\":2,\"104\":3,\"105\":2,\"106\":1,\"110\":5,\"115\":1,\"116\":1,\"118\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
